{"version":3,"sources":["webpack:///client-node.js","webpack:///webpack/bootstrap dff9bdf2fb58856800a1","webpack:///./src/lib/error.js","webpack:///external \"lodash/assign\"","webpack:///./src/lib/deferred.js","webpack:///external \"event-emitter-extra\"","webpack:///external \"lodash/isObject\"","webpack:///external \"lodash/isString\"","webpack:///./src/client/client-web.js","webpack:///external \"request\"","webpack:///external \"ws\"","webpack:///./src/lib/closestatus.js","webpack:///./src/lib/message.js","webpack:///./src/lib/utils.js","webpack:///external \"debug\"","webpack:///external \"lodash/debounce\"","webpack:///external \"lodash/defaultsDeep\"","webpack:///external \"lodash/forEach\"","webpack:///external \"lodash/isBoolean\"","webpack:///external \"lodash/isFunction\"","webpack:///external \"lodash/isInteger\"","webpack:///external \"lodash/isNumber\"","webpack:///external \"lodash/isUndefined\"","webpack:///external \"lodash/values\"","webpack:///./src/client/client-node.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__esModule","o","object","property","prototype","hasOwnProperty","p","s","LineError","code","message","payload","this","stack","Error","require","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Deferred","_this","_ref","arguments","undefined","_ref$handler","handler","_ref$onExpire","onExpire","_ref$timeout","timeout","_ref$rejectOnExpire","rejectOnExpire","resolve_","reject_","timeout_","timeoutDuration_","rejectOnExpire_","onExpire_","isFinished_","promise","Promise","resolve","reject","err","setTimeout","expire","bind","data","clearTimeout_","ErrorCode","EXPIRED","_len","args","Array","_key","then","apply","_len2","_key2","catch","clearTimeout","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","Message","EventEmitterExtra","forEach","debounce","isObject","isBoolean","isString","isNumber","isInteger","defaultsDeep","debug","CloseStatus","Client","_EventEmitterExtra","url","options","getPrototypeOf","trim","INVALID_OPTIONS","urlFollowed","handshake","responseTimeout","disconnectTimeout","pingInterval","reconnect","reconnectOptions","initialDelay","multiply","maxDelay","randomness","uptime","uptimeOptions","interval","window","followRedirections","JSON","stringify","ws_","id","state","State","READY","reconnectState_","disabled","attempt","deferreds_","disconnectTimeout_","uptimeBuffer_","uptimeBufferLength_","Math","round","uptimeInterval_","setInterval","uptimeTick_","autoPing_","ping","CONNECTED","DISCONNECTED","WebSocket","bindEvents_","CONNECTING","emit","Event","WEBSOCKET_ERROR","_this2","connect","removeListeners","onConnectingError","onConnected","onDisconnected","e","removeListener","CONNECTING_ERROR","once","reason","opt_retry","_this3","HANDSHAKING","close","rejectAllDeferreds_","cancel","ERROR","DISCONNECT_TIMEOUT","onClose_","DISCONNECTING","retry","_this4","disconnect","onopen","onOpen_","onclose","onerror","onError_","onmessage","onMessage_","_this5","Name","HANDSHAKE","send_","resetReconnectState_","HANDSHAKE_ERROR","HANDSHAKE_FAILED","MESSAGE_TIMEOUT","MESSAGE_REJECTED","HANDSHAKE_REJECTED","closeEvent","_this6","unBindEvents_","max","min","random","_this7","eventName","httpUrl","ws2http","fetchResponseUrl","httpUrlFollowed","wsUrl","http2ws","parse","INVALID_JSON","PING","onPingMessage_","RESPONSE","onResponseMessage_","ReservedNames","indexOf","onMessageWithResponse_","onMessageWithoutResponse_","sendWithoutResponse_","createResponse","deferred","_this8","MESSAGE_NOT_RESPONDED","dispose","opt_timeout","_this9","setId","_this10","readyState","messageStr","toString","send","_this11","currentSocket","PING_FAILED","PING_ERROR","push","splice","filter","val","_this12","removeAllListeners","clearInterval","DISPOSED","rv","mapping","ws://","wss://","replace","substr","http://","https://","req","XMLHttpRequest","addEventListener","responseURL","open","INTERNAL_ERROR","UNKNOWN_ERROR","isUndefined","values","assign","_require","generateDummyId","isResponded_","raw","MISSING_ID","ALREADY_RESPONDED","err_","events","eventNames","event","pow","slice","global","request","head","followRedirect","on","response","statusCode","headers","location"],"mappings":"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","file":"client-node.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 22);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nfunction LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = new Error().stack;\n}\nLineError.prototype = new Error();\n\nmodule.exports = LineError;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/assign\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LineError = __webpack_require__(0);\n\nvar Deferred = function () {\n    function Deferred() {\n        var _this = this;\n\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref$handler = _ref.handler,\n            handler = _ref$handler === undefined ? function () {} : _ref$handler,\n            _ref$onExpire = _ref.onExpire,\n            onExpire = _ref$onExpire === undefined ? function () {} : _ref$onExpire,\n            _ref$timeout = _ref.timeout,\n            timeout = _ref$timeout === undefined ? 0 : _ref$timeout,\n            _ref$rejectOnExpire = _ref.rejectOnExpire,\n            rejectOnExpire = _ref$rejectOnExpire === undefined ? true : _ref$rejectOnExpire;\n\n        _classCallCheck(this, Deferred);\n\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.rejectOnExpire_ = rejectOnExpire;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve_ = resolve;\n            _this.reject_ = reject;\n\n            try {\n                handler(_this);\n            } catch (err) {\n                _this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n    _createClass(Deferred, [{\n        key: 'resolve',\n        value: function resolve(data) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.resolve_(data);\n        }\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.reject_(err);\n        }\n    }, {\n        key: 'expire',\n        value: function expire() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.onExpire_();\n\n            if (this.rejectOnExpire_) this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, 'Timeout ' + this.timeoutDuration_ + ' ms exceed'));\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n        }\n    }, {\n        key: 'delay',\n        value: function delay(timeout) {\n            if (this.timeoutDuration_ > 0) {\n                this.clearTimeout_();\n                this.timeout_ = setTimeout(this.expire.bind(this), timeout || this.timeoutDuration_);\n            }\n        }\n    }, {\n        key: 'then',\n        value: function then() {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            return this.promise.then.apply(this.promise, args);\n        }\n    }, {\n        key: 'catch',\n        value: function _catch() {\n            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n            }\n\n            return this.promise.catch.apply(this.promise, args);\n        }\n    }, {\n        key: 'clearTimeout_',\n        value: function clearTimeout_() {\n            if (this.timeout_) {\n                clearTimeout(this.timeout_);\n                this.timeout_ = null;\n            }\n        }\n    }]);\n\n    return Deferred;\n}();\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\nmodule.exports = Deferred;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"event-emitter-extra\");\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isObject\");\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isString\");\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Message = __webpack_require__(10);\nvar EventEmitterExtra = __webpack_require__(3);\nvar Deferred = __webpack_require__(2);\nvar assign = __webpack_require__(1);\nvar forEach = __webpack_require__(15);\nvar debounce = __webpack_require__(13);\nvar isObject = __webpack_require__(4);\nvar isBoolean = __webpack_require__(16);\nvar isString = __webpack_require__(5);\nvar isNumber = __webpack_require__(19);\nvar isInteger = __webpack_require__(18);\nvar defaultsDeep = __webpack_require__(14);\nvar debug = __webpack_require__(12)('line:client');\nvar LineError = __webpack_require__(0);\nvar CloseStatus = __webpack_require__(9);\n\n/**\n * Line client class.\n *\n * @class Client\n * @extends {EventEmitterExtra}\n * @param {string=} url Server url, default: `ws://localhost`.\n * @param {Object=} options Options object.\n * @param {Object=} options.handshake Handshake options\n * @param {number=} options.handshake.timeout Handshake timeout duration in milliseconds.\n *      Default: `30000` (30 seconds).\n * @param {any=} options.handshake.payload Handshake payload that will be send to server.\n * @param {number=} options.responseTimeout This is the timeout for getting response from the server\n *      when using `client.send()` method. Default: `10000` (10 seconds). Note that this option is ineffective for\n *      `client.sendWithoutResponse()` method.\n * @param {number=} options.disconnectTimeout In some browsers, `close` frame is not fired immediately.\n *      This timeout is for starting `close` procedure even if close frame is not arrived. Default: `5000` (5 seconds).\n * @param {number=} options.pingInterval Pinging interval. Default: `20000` (20 seconds).\n * @param {boolean=} options.reconnect Whether try to reconnect server after unexpected disconnection,\n *      default `true`.\n * @param {Object=} options.reconnectOptions Reconnection options.\n * @param {number=} options.reconnectOptions.initialDelay In milliseconds. Default: `1000` (1 second).\n * @param {number=} options.reconnectOptions.multiply Default: `1.5`\n * @param {number=} options.reconnectOptions.maxDelay In milliseconds. Default: `30000`\n * @param {number=} options.reconnectOptions.randomness Random delay multiplier. Default: `0.5`\n * @param {boolean=} options.uptime Whether keep & calculate uptime, default `false`.\n *      If this option is not true, `client.getUptime()` returns undefined.\n * @param {Object=} options.uptimeOptions Uptime options.\n * @param {number=} options.uptimeOptions.interval Uptime checking interval. In milliseconds. Default: `5000` (5 seconds).\n * @param {number=} options.uptimeOptions.window Uptime checking window length. In milliseconds. Default: `300000` (5 minutes)\n * @param {boolean=} options.followRedirections Attempt to follow 30X redirections. If this options is set, after\n *      a native websocket connection error, line will try to make a http request to server url. If it is success,\n *      final response url will be used as server after couple of connection attempts. Default: `false`\n * @property {string} url Server url\n * @property {string} id Unique connection id assigned by the server. It will be accessible after handshake.\n * @property {Client.State} state Connection state\n * @example\n * // Add line-client to your html document\n * <script src=\"./node_modules/line-socket/dist/client-web-globals.js\"></script>\n *\n * // For web browsers (consuming as a commonjs module)\n * const LineClient = require('line-socket/client-web');\n *\n * // For node.js\n * const LineClient = require('line-socket/client-node');\n *\n * // Usage\n * const client = new LineClient('ws://localhost:8080');\n * client.connect();\n */\n\nvar Client = function (_EventEmitterExtra) {\n    _inherits(Client, _EventEmitterExtra);\n\n    function Client() {\n        var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ws://localhost';\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Client);\n\n        var _this = _possibleConstructorReturn(this, (Client.__proto__ || Object.getPrototypeOf(Client)).call(this));\n\n        if (!isString(url) || url.trim().length == 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Url parameter must be string and cannot be empty');\n\n        if (!isObject(options)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Options parameter must be an object');\n\n        _this.url = url.trim();\n        _this.urlFollowed = null;\n        _this.options = defaultsDeep(options, {\n            handshake: {\n                timeout: 30000,\n                payload: undefined\n            },\n            responseTimeout: 10000,\n            disconnectTimeout: 5000,\n            pingInterval: 20000,\n            reconnect: true,\n            reconnectOptions: {\n                initialDelay: 1000,\n                multiply: 1.5,\n                maxDelay: 30000,\n                randomness: 0.5\n            },\n            uptime: false,\n            uptimeOptions: {\n                interval: 5000,\n                window: 300000\n            },\n            followRedirections: false\n        });\n\n        if (!isObject(_this.options.handshake)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.handshake\" must be an object');\n\n        if (!isInteger(_this.options.handshake.timeout) || _this.options.handshake.timeout < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.handshake.timeout\" must be a positive integer or zero');\n\n        try {\n            JSON.stringify(_this.options.handshake.payload);\n        } catch (err) {\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.handshake.payload\" must be json friendly, probably circular dependency?');\n        }\n\n        if (!isInteger(_this.options.responseTimeout) || _this.options.responseTimeout < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.responseTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.disconnectTimeout) || _this.options.disconnectTimeout < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.disconnectTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.pingInterval) || _this.options.pingInterval < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.pingInterval\" must be a positive integer or zero');\n\n        if (!isBoolean(_this.options.reconnect)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnect\" must be a boolean');\n\n        if (!isObject(_this.options.reconnectOptions)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions\" must be an object');\n\n        if (!isInteger(_this.options.reconnectOptions.initialDelay) || _this.options.reconnectOptions.initialDelay <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.initialDelay\" must be a positive integer');\n\n        if (!isNumber(_this.options.reconnectOptions.multiply) || _this.options.reconnectOptions.multiply < 1) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.multiply\" must be a number >= 1');\n\n        if (!isInteger(_this.options.reconnectOptions.maxDelay) || _this.options.reconnectOptions.maxDelay <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.maxDelay\" must be a positive integer');\n\n        if (_this.options.reconnectOptions.maxDelay < _this.options.reconnectOptions.initialDelay) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.maxDelay\" must be a greater than initial delay');\n\n        if (!isNumber(_this.options.reconnectOptions.randomness) || _this.options.reconnectOptions.randomness < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.randomness\" must be a positive number or zero');\n\n        if (!isBoolean(_this.options.uptime)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptime\" must be a boolean');\n\n        if (!isObject(_this.options.uptimeOptions)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions\" must be an object');\n\n        if (!isInteger(_this.options.uptimeOptions.interval) || _this.options.uptimeOptions.interval <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions.interval\" must be a positive integer');\n\n        if (!isInteger(_this.options.uptimeOptions.window) || _this.options.uptimeOptions.window <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions.window\" must be a positive integer');\n\n        if (_this.options.uptimeOptions.window < _this.options.uptimeOptions.interval) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions.window\" must be a greater than interval');\n\n        if (!isBoolean(_this.options.followRedirections)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.followRedirections\" must be a boolean');\n\n        _this.ws_ = null;\n        _this.id = null;\n        _this.state = Client.State.READY;\n\n        _this.reconnectState_ = { disabled: false, attempt: 0, timeout: null };\n        _this.deferreds_ = {};\n        _this.disconnectTimeout_ = null;\n        _this.uptimeBuffer_ = [];\n        _this.uptimeBufferLength_ = Math.round(_this.options.uptimeOptions.window / _this.options.uptimeOptions.interval);\n        _this.uptimeInterval_ = options.uptime ? setInterval(_this.uptimeTick_.bind(_this), _this.options.uptimeOptions.interval) : null;\n        _this.autoPing_ = debounce(function () {});\n\n        if (_this.options.pingInterval > 0) {\n            _this.autoPing_ = debounce(function () {\n                _this.ping().then(function () {\n                    // Ping successfull. If we still connected, debounce next one!\n                    if (_this.options.pingInterval > 0 && _this.state == Client.State.CONNECTED) {\n                        _this.autoPing_(); // Recursive\n                    }\n                }).catch(function () {/* ping() method handles disconnection the logic itself */});\n            }, _this.options.pingInterval);\n        }\n        return _this;\n    }\n\n    /**\n     * Starts the connection procedure.\n     *\n     * If server url is invalid or there is a security error,\n     * this method will throw `Client.ErrorCode.WEBSOCKET_ERROR`.\n     *\n     * When procedure is started, `Client.Event.CONNECTING` event will be emitted.\n     *\n     * If an error occured during connection or handshake, the client will emit `Client.Event.CONNECTING_ERROR`.\n     *\n     * If connection is failed for some reason and `options.reconnect` is `true`. The client will\n     * retry to connect.\n     *\n     * @returns {boolean}\n     * @example\n     * client.connect();\n     *\n     * client.on(Client.Event.CONNECTED, () => {\n     *   console.log('Client connected.');\n     * });\n     *\n     * client.on(Client.Event.CONNECTING_ERROR, (err) => {\n     *   console.log('Could not connect!', err);\n     * });\n     */\n\n\n    _createClass(Client, [{\n        key: 'connect',\n        value: function connect() {\n            switch (this.state) {\n                case Client.State.DISCONNECTED:\n                case Client.State.READY:\n                    var url = this.url;\n\n                    if (this.options.followRedirections && this.urlFollowed) {\n                        url = this.urlFollowed;\n                        debug('Following redirection \"' + this.url + '\" -> \"' + this.urlFollowed + '\"');\n                    }\n\n                    debug('Connecting to \"' + url + '\" ...');\n\n                    try {\n                        this.reconnectState_.disabled = false;\n                        this.ws_ = new WebSocket(url);\n                        this.bindEvents_();\n                        this.state = Client.State.CONNECTING;\n                        this.emit(Client.Event.CONNECTING);\n                        return true;\n                    } catch (err) {\n                        throw new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Native websocket error. Invalid url or security error', err);\n                    }\n\n                default:\n                    debug('Ignoring connect() call, client is in \"' + this.state + '\" state');\n                    return false;\n            }\n        }\n\n        /**\n         * TODO: This is an experimental method currently, it's just used in tests.\n         * DO NOT use in production.\n         *\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'connectAsync',\n        value: function connectAsync() {\n            var _this2 = this;\n\n            return new Promise(function (resolve, reject) {\n                _this2.connect(); // Can throw WEBSOCKET_ERROR or ignore silently\n\n                var removeListeners = function removeListeners() {};\n\n                var onConnectingError = function onConnectingError(err) {\n                    removeListeners();\n                    reject(err);\n                };\n\n                var onConnected = function onConnected(data) {\n                    removeListeners();\n                    resolve(data);\n                };\n\n                var onDisconnected = function onDisconnected(e) {\n                    removeListeners();\n                    reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Client disconnected', e));\n                };\n\n                removeListeners = function removeListeners() {\n                    _this2.removeListener(Client.Event.CONNECTING_ERROR, onConnectingError);\n                    _this2.removeListener(Client.Event.CONNECTED, onConnected);\n                    _this2.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n                };\n\n                _this2.once(Client.Event.CONNECTING_ERROR, onConnectingError);\n                _this2.once(Client.Event.CONNECTED, onConnected);\n                _this2.once(Client.Event.DISCONNECTED, onDisconnected);\n            });\n        }\n\n        /**\n         * Gracefully closes the connection. This method can throw `Client.ErrorCode.WEBSOCKET_ERROR` if\n         * provided parameters are invalid. If websocket is not closed after `options.disconnectTimeout` ms,\n         * the client will start the disconnection procedure forcefully.\n         *\n         * @param {number=} code A numeric value indicating the status code explaining why the connection is being closed.\n         *      Must be between 1000-4999. Default is 1000.\n         * @param {any=} reason A human-readable string explaining why the connection is closing. This string must\n         *      be no longer than 123 bytes of UTF-8 text (not characters).\n         * @param {boolean=} opt_retry Whether retry to connect after disconnection.\n         * @returns {boolean}\n         * @example\n         * client.disconnect();\n         *\n         * client.on(Client.Event.DISCONNECTED, (e) => {\n         *   console.log('Disconnected', e.code, e.reason);\n         * });\n         */\n\n    }, {\n        key: 'disconnect',\n        value: function disconnect(code, reason, opt_retry) {\n            var _this3 = this;\n\n            switch (this.state) {\n                case Client.State.CONNECTING:\n                case Client.State.HANDSHAKING:\n                case Client.State.CONNECTED:\n                    debug('Disconnecting... (State: ' + this.state + ')');\n\n                    try {\n                        this.ws_.close(code || 1000, reason); // Can throw INVALID_ACCESS_ERR, SYNTAX_ERR\n                        debug('Websocket is closed');\n                        this.reconnectState_.disabled = !opt_retry;\n                        this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Disconnect procedure started'));\n                        this.autoPing_.cancel();\n\n                        // Wait \"close\" event for some time, then manually start onClose procedure\n                        if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n                        if (this.options.disconnectTimeout) {\n                            this.disconnectTimeout_ = setTimeout(function () {\n                                debug('Disconnect timeout exceeded, force disconnecting...');\n\n                                _this3.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.DISCONNECT_TIMEOUT, 'Disconnect timeout exceeded, force disconnecting...'));\n\n                                _this3.onClose_(CloseStatus.DISCONNECT_TIMEOUT);\n\n                                clearTimeout(_this3.disconnectTimeout_);\n                            }, this.options.disconnectTimeout);\n                        }\n\n                        this.state = Client.State.DISCONNECTING;\n                        this.emit(Client.Event.DISCONNECTING);\n\n                        return true;\n                    } catch (err) {\n                        throw new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Could not disconnect. Invalid code or reason, check payload.', err);\n                    }\n\n                default:\n                    debug('Ignoring disconnect() call, client is in \"' + this.state + '\" state.');\n                    return false;\n            }\n        }\n\n        /**\n         * TODO: This is an experimental method currently, it's just used in tests.\n         * DO NOT use in production.\n         *\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'disconnectAsync',\n        value: function disconnectAsync(code, reason, retry) {\n            var _this4 = this;\n\n            return new Promise(function (resolve, reject) {\n                _this4.disconnect(code, reason, retry); // Can throw WEBSOCKET_ERROR or ignore silently\n\n                var onDisconnected = function onDisconnected(e) {\n                    // this.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n                    resolve(e);\n                };\n\n                _this4.once(Client.Event.DISCONNECTED, onDisconnected);\n            });\n        }\n\n        /**\n         * Binds websocket events\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'bindEvents_',\n        value: function bindEvents_() {\n            debug('Binding native event handlers.');\n            this.ws_.onopen = this.onOpen_.bind(this);\n            this.ws_.onclose = this.onClose_.bind(this);\n            this.ws_.onerror = this.onError_.bind(this);\n            this.ws_.onmessage = this.onMessage_.bind(this);\n        }\n\n        /**\n         * Unbinds websocket events\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'unBindEvents_',\n        value: function unBindEvents_() {\n            if (!this.ws_) return;\n            debug('Unbinding native event handlers.');\n            this.ws_.onopen = function () {};\n            this.ws_.onclose = function () {};\n            this.ws_.onerror = function () {};\n            this.ws_.onmessage = function () {};\n        }\n\n        /**\n         * Native \"open\" event handler. At this time we will start the handshakin process.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'onOpen_',\n        value: function onOpen_() {\n            var _this5 = this;\n\n            debug('Native \"open\" event received, starting handshake process');\n\n            this.state = Client.State.HANDSHAKING;\n            var message = new Message({\n                name: Message.Name.HANDSHAKE,\n                payload: this.options.handshake.payload // We're sure that this is json friendly\n            });\n\n            this.send_(message, this.options.handshake.timeout).then(function (data) {\n                // Message is sent and we got the response!\n                if (!isObject(data)) {\n                    debug('Unexpected handshake response!?');\n\n                    _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Handshake response is not object. Aborting handshake...', data));\n\n                    _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, unexpected handshake response.', true);\n                    return;\n                }\n\n                debug('Handshake successful.');\n                _this5.resetReconnectState_();\n                _this5.id = data.id;\n                _this5.state = Client.State.CONNECTED;\n                _this5.autoPing_(); // Start auto-ping\n\n                debug('Emitting \"connected\" event...');\n                _this5.emit(Client.Event.CONNECTED, data.payload);\n            }).catch(function (err) {\n                if (err instanceof LineError) {\n                    switch (err.code) {\n                        case Client.ErrorCode.DISCONNECTED:\n                            debug('Handshake failed, connection lost (disconnected)');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Connection lost during handshake.'));\n                            return;\n\n                        case Client.ErrorCode.MESSAGE_TIMEOUT:\n                            // TODO: Try again maybe?\n                            debug('Handshake failed, message timeout');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Handshake failed, request timeout.'));\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, request timeout.', true);\n\n                        case Client.ErrorCode.MESSAGE_REJECTED:\n                            debug('Handshake REJECTED!');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_REJECTED, 'Handshake rejected, check payload for further details.', err && err.payload));\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_REJECTED.code, 'Handshake rejected', true);\n\n                        case Client.ErrorCode.WEBSOCKET_ERROR:\n                            debug('Handshake failed, native websocket error');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Handshake failed. Websocket protocol error, check payload.', err && err.payload));\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, native websocket error', true);\n\n                        default:\n                            debug('Handshake failed, unknown line error', err);\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown line error', true);\n                    }\n                }\n\n                // Unknown error\n                debug('Handshake failed, unknown error', err);\n                return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown error', true);\n            });\n        }\n\n        /**\n         * Native \"close\" event handler.\n         *\n         * @param {Event} closeEvent Native close event.\n         * @param {number} closeEvent.code Close status code sent by server.\n         * @param {string=} closeEvent.reason Human readable close reason.\n         * @ignore\n         */\n\n    }, {\n        key: 'onClose_',\n        value: function onClose_(closeEvent) {\n            var _this6 = this;\n\n            debug('Native \"close\" event received in \"' + this.state + '\" state (code: ' + closeEvent.code + ', reason: ' + closeEvent.reason + ')');\n\n            if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n            this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Client is disconnected'));\n            this.unBindEvents_();\n            this.autoPing_.cancel();\n\n            this.id = null;\n            this.ws_ = null;\n\n            debug('Emitting \"disconnected\" event...');\n            this.state = Client.State.DISCONNECTED;\n            this.emit(Client.Event.DISCONNECTED, closeEvent);\n\n            if (this.options.reconnect && !this.reconnectState_.disabled) {\n                var timeout = this.options.reconnectOptions.initialDelay * Math.max(this.options.reconnectOptions.multiply * this.reconnectState_.attempt, 1);\n                timeout = Math.min(timeout, this.options.reconnectOptions.maxDelay);\n                timeout += Math.round(Math.random() * this.options.reconnectOptions.randomness * timeout);\n\n                debug('Will try to reconnect in ' + timeout + ' ms');\n\n                this.reconnectState_.timeout && clearTimeout(this.reconnectState_.timeout);\n                this.reconnectState_.timeout = setTimeout(function () {\n                    _this6.reconnectState_.attempt++;\n                    _this6.connect();\n                }, timeout);\n            }\n        }\n\n        /**\n         * Native \"error\" handler. A \"close\" event will ALWAYS follow this event.\n         * See: https://www.w3.org/TR/websockets/#closeWebSocket\n         * So, if client state is connecting/handshaking, emit `CONNECTING_ERROR`.\n         *\n         * @param {Error} err Native error object.\n         * @ignore\n         */\n\n    }, {\n        key: 'onError_',\n        value: function onError_(err) {\n            var _this7 = this;\n\n            debug('Native \"error\" event received in \"' + this.state + '\" state.');\n            var eventName = Client.Event.ERROR;\n\n            if (this.state == Client.State.CONNECTING || this.state == Client.State.HANDSHAKING) {\n                eventName = Client.Event.CONNECTING_ERROR;\n            }\n\n            this.emit(eventName, new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Native websocket error occured, check payload.', err));\n\n            // For 30X redirects, we get this error: \"Unexpected response code: 30X\"\n            // Attempt to make a http request to server url (this request will follow redirections).\n            // If it is successful, use the final response url as websocket url\n            if (this.options.followRedirections) {\n                debug('Attempting to follow redirections...');\n                var httpUrl = Client.ws2http(this.url);\n\n                if (httpUrl) {\n                    debug('Making a request to \"' + httpUrl + '\" for following');\n                    Client.fetchResponseUrl(httpUrl).then(function (httpUrlFollowed) {\n                        var wsUrl = Client.http2ws(httpUrlFollowed);\n                        if (!wsUrl) return debug('Could not convert http url \"' + httpUrlFollowed + '\" to ws');\n                        if (_this7.urlFollowed == wsUrl) return;\n                        debug('Updating followed url to \"' + wsUrl + '\"');\n                        _this7.urlFollowed = wsUrl;\n                    }).catch(function (err) {\n                        return debug('Could not follow redirection, ignoring...', err);\n                    });\n                } else {\n                    debug('Could not convert ws url to http');\n                }\n            }\n        }\n\n        /**\n         * Native \"message\" handler.\n         *\n         * @param {Event} e Native message event.\n         * @param {string} e.data Raw message data.\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessage_',\n        value: function onMessage_(e) {\n            debug('Native \"message\" event received in \"' + this.state + '\" state.');\n            var message = void 0;\n\n            // A message is recieved, debounce our auto-ping handler\n            if (this.state == Client.State.CONNECTED) {\n                this.autoPing_();\n            }\n\n            /**\n             * Try to parse incoming message\n             */\n            try {\n                message = Message.parse(e.data);\n            } catch (err) {\n                debug('Could not parse message', e.data);\n                this.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.INVALID_JSON, 'Could not parse incoming message, invalid json. Check payload for incoming data.', e.data));\n                return;\n            }\n\n            /**\n             * Route the incoming message\n             */\n            if (message.name == Message.Name.PING) {\n                // Ping message arrived\n                this.onPingMessage_(message);\n            } else if (message.name == Message.Name.RESPONSE) {\n                // Response message arrive\n                this.onResponseMessage_(message);\n            } else if (Message.ReservedNames.indexOf(message.name) == -1) {\n                // If message name is not reserved\n                if (!message.id) {\n                    // A message arrived without response\n                    this.onMessageWithoutResponse_(message);\n                } else {\n                    // A message arrived awaiting its response\n                    this.onMessageWithResponse_(message);\n                }\n            } else {\n                debug('Could not route the message', message);\n            }\n        }\n\n        /**\n         * On \"ping\" message handler. Respond with \"pong\".\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onPingMessage_',\n        value: function onPingMessage_(message) {\n            debug('Ping received, responding \"pong\"...');\n\n            this.sendWithoutResponse_(message.createResponse(null, 'pong')).catch(function (err) {\n                return debug('Ping response failed to send back, ignoring for now...', err);\n            });\n        }\n\n        /**\n         * A response is arrived, find the related deferred and finalize it.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onResponseMessage_',\n        value: function onResponseMessage_(message) {\n            var deferred = this.deferreds_[message.id];\n\n            if (!deferred) return debug('Unknown message response, ignoring... (name=\"' + message.name + '\" id=\"' + message.id + '\")');\n\n            debug('Message response arrived: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n            if (message.err) {\n                // Server rejects the message\n                deferred.reject(new LineError(Client.ErrorCode.MESSAGE_REJECTED, 'Message is rejected by server, check payload.', message.err));\n            } else {\n                // Server resolves the message\n                deferred.resolve(message.payload);\n            }\n\n            delete this.deferreds_[message.id];\n        }\n\n        /**\n         * A message is arrived without awaiting a response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithoutResponse_',\n        value: function onMessageWithoutResponse_(message) {\n            debug('Message without response: name=\"' + message.name + '\"');\n            this.emit(message.name, message);\n        }\n\n        /**\n         * A message is arrived and server is waiting for a response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithResponse_',\n        value: function onMessageWithResponse_(message) {\n            var _this8 = this;\n\n            debug('Message with response: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n            message.once('resolved', function (payload) {\n                debug('Client resolving: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n                // Try to send our response back to server, if not emit an error\n                _this8.sendWithoutResponse_(message.createResponse(null, payload)).catch(function (err) {\n                    _this8.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (resolve)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            message.once('rejected', function (err) {\n                debug('Client rejecting: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n                // Try to send our response back to server, if not emit an error\n                _this8.sendWithoutResponse_(message.createResponse(err)).catch(function (err) {\n                    _this8.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (reject)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            this.emit(message.name, message);\n        }\n\n        /**\n         * Sends a message to server with awaiting its response. This method returns a promise\n         * which resolves the payload parameter will be passed into `message.resolve(...)` in server-side.\n         *\n         * If server rejects the message with `message.reject(...)`, this promise will be rejected with\n         * `Client.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n         * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {string} name Message name.\n         * @param {any=} payload Optional message payload.\n         * @param {number=} timeout Timeout duration for waiting the response. If this parameter\n         *      is not provided, `options.responseTimeout` will be used.\n         * @returns {Promise}\n         * @example\n         * client\n         *   .send('hello', {some: 'payload'})\n         *   .then((data) => {\n         *     console.log('Sent and got the response', data);\n         *   })\n         *   .catch((err) => {\n         *     if (err.code == Client.ErrorCode.MESSAGE_REJECTED) {\n         *       console.log('Message rejected by server', err.payload);\n         *     } else if (err.code == Client.ErrorCode.MESSAGE_TIMEOUT) {\n         *       console.log('Server did not responded, timeout exceeded');\n         *     } else {\n         *       console.log('Could not send message', err);\n         *     }\n         *   });\n         */\n\n    }, {\n        key: 'send',\n        value: function send(name, payload, opt_timeout) {\n            // This method is for external usage!\n            if (this.state != Client.State.CONNECTED) {\n                return Promise.reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload });\n                return this.send_(message, opt_timeout);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(Client.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Sends a message to server without waiting its response. This method returns a promise\n         * that resolves with nothing if the message is successfully sent.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {string} name\n         * @param {any=} payload\n         * @returns {Promise}\n         * @example\n         * client\n         *   .sendWithoutResponse('hello', {some: data})\n         *   .then(() => {\n         *     console.log('Message is sent');\n         *   })\n         *   .catch((err) => {\n         *     console.log('Could not send message');\n         *   });\n         */\n\n    }, {\n        key: 'sendWithoutResponse',\n        value: function sendWithoutResponse(name, payload) {\n            // This method is for external usage!\n            if (this.state != Client.State.CONNECTED) {\n                return Promise.reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload }); // Can throw Message.ErrorCode.INVALID_JSON\n                return this.sendWithoutResponse_(message);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(Client.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Base method for sending a message with timeout. Please favor this method internally\n         * instead of using `send` method.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n         * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {Message} message\n         * @param {number=} opt_timeout\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'send_',\n        value: function send_(message, opt_timeout) {\n            var _this9 = this;\n\n            var timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.options.responseTimeout;\n            message.setId();\n\n            var deferred = this.deferreds_[message.id] = new Deferred({\n                onExpire: function onExpire() {\n                    delete _this9.deferreds_[message.id];\n                },\n                timeout: timeout\n            });\n\n            return this.sendWithoutResponse_(message).then(function () {\n                return deferred;\n            }).catch(function (err) {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(Client.ErrorCode.MESSAGE_TIMEOUT, 'Message timeout! Its response did not recived after ' + timeout + ' ms');\n                }\n\n                throw err;\n            });\n        }\n\n        /**\n         * Base method for sending a message without response. Please favor this method internally\n         * instead of using `sendWithoutResponse` method.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {Message} message\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'sendWithoutResponse_',\n        value: function sendWithoutResponse_(message) {\n            var _this10 = this;\n\n            if (!this.ws_ || this.ws_.readyState != 1) {\n                return Promise.reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Could not send message, there is no open connection.'));\n            }\n\n            return new Promise(function (resolve, reject) {\n                var messageStr = message.toString();\n\n                try {\n                    debug('Sending message: ' + messageStr);\n                    _this10.ws_.send(messageStr); // Can throw INVALID_STATE_ERR, SYNTAX_ERR\n                    resolve();\n                } catch (err) {\n                    reject(new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Could not send message. Either socket is not connected or syntax error, check payload.', err));\n                }\n            });\n        }\n\n        /**\n         * Sends a ping message to server, if it's failed, the connection\n         * will be closed and will retry to connect again. Server and client ping each\n         * other automatically with an interval.\n         *\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'ping',\n        value: function ping() {\n            var _this11 = this;\n\n            var currentSocket = this.ws_;\n\n            debug('Pinging...');\n            return this.send_(new Message({ name: Message.Name.PING })).catch(function (err) {\n                // If socket is changed, dismiss\n                if (_this11.ws_ != currentSocket) {\n                    debug('Auto-ping failed, but socket is also changed, dismissing...');\n                    return;\n                }\n\n                // No matter what error is, start disconnection process\n                debug('Auto-ping failed, manually disconnecting...');\n                _this11.disconnect(CloseStatus.PING_FAILED.code, 'Auto ping failed', true);\n                throw new LineError(Client.ErrorCode.PING_ERROR, 'Ping failed, disconnecting...', err);\n            });\n        }\n\n        /**\n         * On uptime tick event handler. Check current state and push a marker to buffer.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'uptimeTick_',\n        value: function uptimeTick_() {\n            debug('Uptime Tick');\n            this.uptimeBuffer_.push(this.state == Client.State.CONNECTED);\n\n            if (this.uptimeBuffer_.length > this.uptimeBufferLength_) {\n                this.uptimeBuffer_.splice(0, this.uptimeBufferLength_ - this.uptimeBuffer_.length);\n            }\n        }\n\n        /**\n         * Calculates (connection) uptime for last `options.uptime.window` (default 5 minutes)\n         * with `options.uptime.interval` (default 5 seconds) interval. Returns a number between\n         * 0 and 1. If `options.uptime` is false, this method returns nothing.\n         *\n         * @returns {number?}\n         */\n\n    }, {\n        key: 'getUptime',\n        value: function getUptime() {\n            if (!this.options.uptime) return;\n            if (this.uptimeBuffer_.length == 0) return 0;\n            return this.uptimeBuffer_.filter(function (val) {\n                return val;\n            }).length / this.uptimeBuffer_.length;\n        }\n\n        /**\n         * Disposes the client.\n         *\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            var _this12 = this;\n\n            return new Promise(function (resolve) {\n                debug('Disposing...');\n\n                switch (_this12.state) {\n                    case Client.State.CONNECTING:\n                    case Client.State.HANDSHAKING:\n                    case Client.State.CONNECTED:\n                        _this12.once(Client.Event.DISCONNECTED, function () {\n                            _this12.removeAllListeners();\n                            _this12.uptimeBuffer_ = [];\n                            if (_this12.uptimeInterval_) clearInterval(_this12.uptimeInterval_);\n                            debug('Disposed!');\n                            resolve();\n                        });\n\n                        _this12.disconnect(CloseStatus.DISPOSED.code, CloseStatus.DISPOSED.reason);\n                        break;\n\n                    case Client.State.READY:\n                    case Client.State.DISCONNECTING:\n                    case Client.State.DISCONNECTED:\n                        _this12.resetReconnectState_();\n                        _this12.removeAllListeners();\n                        _this12.uptimeBuffer_ = [];\n                        if (_this12.uptimeInterval_) clearInterval(_this12.uptimeInterval_);\n                        debug('Disposed!');\n                        resolve();\n                        break;\n                }\n            });\n        }\n\n        /**\n         * Reject all the awaiting deferred with given error.\n         *\n         * @param {Error} err An error object to reject all awaiting deferreds.\n         * @ignore\n         */\n\n    }, {\n        key: 'rejectAllDeferreds_',\n        value: function rejectAllDeferreds_(err) {\n            forEach(this.deferreds_, function (deferred) {\n                return deferred.reject(err);\n            });\n            this.deferreds_ = {};\n        }\n\n        /**\n         * Resets the reconnection state.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'resetReconnectState_',\n        value: function resetReconnectState_() {\n            debug('Resetting reconnection state...');\n            if (this.reconnectState_.timeout) clearTimeout(this.reconnectState_.timeout);\n            this.reconnectState_ = { disabled: false, attempt: 0, timeout: null };\n        }\n    }]);\n\n    return Client;\n}(EventEmitterExtra);\n\nClient.ws2http = function (url) {\n    var rv = void 0;\n    var mapping = {\n        'ws://': 'http://',\n        'wss://': 'https://'\n    };\n    forEach(mapping, function (replace, target) {\n        if (url.indexOf(target) != 0) return;\n        rv = replace + url.substr(target.length);\n    });\n    return rv;\n};\n\nClient.http2ws = function (url) {\n    var rv = void 0;\n    var mapping = {\n        'http://': 'ws://',\n        'https://': 'wss://'\n    };\n    forEach(mapping, function (replace, target) {\n        if (url.indexOf(target) != 0) return;\n        rv = replace + url.substr(target.length);\n    });\n    return rv;\n};\n\nClient.fetchResponseUrl = function (url) {\n    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;\n\n    return new Deferred({\n        timeout: timeout,\n        handler: function handler(deferred) {\n            var req = new XMLHttpRequest();\n            req.addEventListener('error', function () {\n                return deferred.reject(new Error('Native XMLHttpRequest error'));\n            });\n            req.addEventListener('abort', function () {\n                return deferred.reject(new Error('Aborted XMLHttpRequest'));\n            });\n            req.addEventListener('load', function () {\n                return deferred.resolve(req.responseURL);\n            });\n            req.open('HEAD', url);\n\n            try {\n                req.send();\n            } catch (err) {\n                deferred.reject(err);\n            }\n        }\n    });\n};\n\n// Expose internal classes\nClient.Message = Message;\nClient.Error = LineError;\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.ErrorCode = {\n    /**\n     * When constructing `new Client()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'cInvalidOptions',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'cInvalidJSON',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates an operational error during the handshake. If `options.reconnect` is true,\n     * the client will try to reconnect again.\n     */\n    HANDSHAKE_ERROR: 'cHandshakeError',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates that server is explicitly rejected the handshake, which probably means\n     * client's handshake payload is not accepted by server.\n     */\n    HANDSHAKE_REJECTED: 'cHandshakeRejected',\n    /**\n     * This error can be seen in rejection of `client.send()` method. This means the\n     * message is reached to server but the timeout is exceeded.\n     */\n    MESSAGE_TIMEOUT: 'cMessageTimeout',\n    /**\n     * This error can be seen in rejection of `client.send()` method, which again indicates that\n     * server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'cMessageRejected',\n    /**\n     * When the response of a message failed to send to server, this error\n     * will be emitted in `Client.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * This error is for native websocket errors. Native error is wrapped by `LineError`\n     * and can be accessible under `err.payload`.\n     */\n    WEBSOCKET_ERROR: 'cWebsocketError',\n    /**\n     * When disconnect timeout is exceed, this error will be emited in\n     * `Client.Events.ERROR` event. After this event, the disconnect\n     * procedure will be started forcefully.\n     */\n    DISCONNECT_TIMEOUT: 'cDisconnectError',\n    /**\n     * This error can be seen in rejection of `client.ping()` method. After this error,\n     * client will be disconnected.\n     */\n    PING_ERROR: 'cPingError',\n    /**\n     * This error indicates the action is prohibited because client is not\n     * in connected state or connection is closing.\n     */\n    DISCONNECTED: 'cDisconnected'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.State = {\n    /**\n     * `ready`\n     */\n    READY: 'ready',\n    /**\n     * `connecting`\n     */\n    CONNECTING: 'connecting',\n    /**\n     * `handshaking`\n     */\n    HANDSHAKING: 'handshaking',\n    /**\n     * `connected`\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnecting`\n     */\n    DISCONNECTING: 'disconnecting',\n    /**\n     * `disconnected`\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.Event = {\n    /**\n     * `_connecting`\n     */\n    CONNECTING: '_connecting',\n    /**\n     * `_connecting_error`\n     */\n    CONNECTING_ERROR: '_connecting_error',\n    /**\n     * `_connected`\n     */\n    CONNECTED: '_connected',\n    /**\n     * `_disconnecting`\n     */\n    DISCONNECTING: '_disconnecting',\n    /**\n     * `_disconnected`\n     */\n    DISCONNECTED: '_disconnected',\n    /**\n     * `_error`\n     */\n    ERROR: '_error'\n};\n\nmodule.exports = Client;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"request\");\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"ws\");\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nmodule.exports = {\n    INTERNAL_ERROR: { code: 4200, reason: 'Internal error' },\n    PING_FAILED: { code: 4201, reason: 'Ping failed' },\n    HANDSHAKE_FAILED: { code: 4202, reason: 'Handshake failed' },\n    HANDSHAKE_REJECTED: { code: 4203, reason: 'Handshake rejected' },\n    DISCONNECT_TIMEOUT: { code: 4204, reason: 'Disconnect timeout' },\n    DISPOSED: { code: 4205, reason: 'Client disposed' },\n    UNKNOWN_ERROR: { code: 4299, reason: 'Unknown error' }\n};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar isUndefined = __webpack_require__(20);\nvar isString = __webpack_require__(5);\nvar isObject = __webpack_require__(4);\nvar isFunction = __webpack_require__(17);\nvar values = __webpack_require__(21);\nvar assign = __webpack_require__(1);\n\nvar _require = __webpack_require__(11),\n    generateDummyId = _require.generateDummyId;\n\nvar EventEmitterExtra = __webpack_require__(3);\nvar LineError = __webpack_require__(0);\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\n\nvar Message = function (_EventEmitterExtra) {\n    _inherits(Message, _EventEmitterExtra);\n\n    _createClass(Message, null, [{\n        key: 'parse',\n        value: function parse(raw) {\n            try {\n                var data = JSON.parse(raw);\n\n                // If error is error-like object, construct real error\n                if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                    data.e = assign(new Error(), data.e);\n                }\n\n                return new Message({\n                    name: data.n,\n                    payload: data.p,\n                    err: data.e,\n                    id: data.i\n                });\n            } catch (err) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Could not parse incoming message.');\n            }\n        }\n    }]);\n\n    function Message(_ref) {\n        var name = _ref.name,\n            payload = _ref.payload,\n            id = _ref.id,\n            err = _ref.err;\n\n        _classCallCheck(this, Message);\n\n        var _this = _possibleConstructorReturn(this, (Message.__proto__ || Object.getPrototypeOf(Message)).call(this));\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message payload or error must be json-friendly. Maybe circular json?');\n        }\n\n        _this.name = name;\n        _this.payload = payload;\n        _this.id = id;\n        _this.err = err;\n\n        _this.isResponded_ = false;\n        return _this;\n    }\n\n    _createClass(Message, [{\n        key: 'setId',\n        value: function setId() {\n            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generateDummyId();\n\n            this.id = id;\n            return id;\n        }\n    }, {\n        key: 'createResponse',\n        value: function createResponse(err, payload) {\n            return new Message({ name: '_r', payload: payload, err: err, id: this.id });\n        }\n\n        /**\n         * Resolves the message with sending a response back. If the source\n         * does not expecting a response, you don't need to call these methods.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} payload\n         */\n\n    }, {\n        key: 'resolve',\n        value: function resolve(payload) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be resolved (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(payload);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('resolved', payload);\n        }\n\n        /**\n         * Rejects the message, with sending error response back to the source.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} err\n         */\n\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be rejected (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(err);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('rejected', err);\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            var data = { n: this.name };\n\n            if (!isUndefined(this.payload)) data.p = this.payload;\n\n            if (!isUndefined(this.id)) data.i = this.id;\n\n            if (!isUndefined(this.err)) {\n                data.e = this.err instanceof Error ? assign({\n                    name: this.err.name,\n                    message: this.err.message\n                }, this.err) : this.err;\n            }\n\n            // We're sure the data is json-friendly\n            return JSON.stringify(data);\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            var _this2 = this;\n\n            var events = this.eventNames();\n            events.forEach(function (event) {\n                return _this2.removeAllListeners(event);\n            });\n        }\n    }]);\n\n    return Message;\n}(EventEmitterExtra);\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\n\n\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\nMessage.ReservedNames = values(Message.Name);\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded'\n};\n\nmodule.exports = Message;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\n\nvar assign = __webpack_require__(1);\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId() {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n\n    return (\"0000\" + (Math.random() * Math.pow(36, length) << 0).toString(36)).slice(-length);\n}\n\nmodule.exports = { generateDummyId: generateDummyId };\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"debug\");\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/debounce\");\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/defaultsDeep\");\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/forEach\");\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isBoolean\");\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isFunction\");\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isInteger\");\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isNumber\");\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isUndefined\");\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/values\");\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nglobal.WebSocket = __webpack_require__(8); // Polyfill for extending browser code\nvar Client = __webpack_require__(6);\nvar request = __webpack_require__(7);\nvar Deferred = __webpack_require__(2);\n\n/**\n * Polyfill http request for node\n */\nClient.fetchResponseUrl = function (url) {\n    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;\n\n    return new Deferred({\n        timeout: timeout,\n        handler: function handler(deferred) {\n            request.head(url, { followRedirect: false }).on('response', function (response) {\n                if (response.statusCode != 301 && response.statusCode != 302) {\n                    return deferred.reject(new Error('Not redirected, status code: \"' + response.statusCode + '\"'));\n                }\n\n                if (!response.headers.location) {\n                    return deferred.reject(new Error('Redirected, but no location header'));\n                }\n\n                deferred.resolve(response.headers.location);\n            }).on('error', function (err) {\n                return deferred.reject(err);\n            });\n        }\n    });\n};\n\nmodule.exports = Client;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// client-node.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 22);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap dff9bdf2fb58856800a1","function LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = (new Error()).stack;\n}\nLineError.prototype = new Error;\n\n\nmodule.exports = LineError;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/error.js","module.exports = require(\"lodash/assign\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/assign\"\n// module id = 1\n// module chunks = 0","const LineError = require('./error');\n\n\nclass Deferred {\n    constructor({\n        handler = () => {},\n        onExpire = () => {},\n        timeout = 0,\n        rejectOnExpire = true\n    } = {}) {\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.rejectOnExpire_ = rejectOnExpire;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve_ = resolve;\n            this.reject_ = reject;\n\n            try {\n                handler(this);\n            } catch (err) {\n                this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n\n    resolve(data) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.resolve_(data);\n    }\n\n\n    reject(err) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.reject_(err);\n    }\n\n\n    expire() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.onExpire_();\n\n        if (this.rejectOnExpire_)\n            this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, `Timeout ${this.timeoutDuration_} ms exceed`));\n    }\n\n\n    dispose() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n    }\n\n    delay(timeout) {\n        if (this.timeoutDuration_ > 0) {\n            this.clearTimeout_();\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout || this.timeoutDuration_);\n        }\n    }\n\n    then(...args) {\n        return this.promise.then.apply(this.promise, args);\n    }\n\n\n    catch(...args) {\n        return this.promise.catch.apply(this.promise, args);\n    }\n\n\n    clearTimeout_() {\n        if (this.timeout_) {\n            clearTimeout(this.timeout_);\n            this.timeout_ = null;\n        }\n    }\n}\n\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\n\nmodule.exports = Deferred;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/deferred.js","module.exports = require(\"event-emitter-extra\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"event-emitter-extra\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"lodash/isObject\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isObject\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"lodash/isString\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isString\"\n// module id = 5\n// module chunks = 0","const Message = require('../lib/message');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst Deferred = require('../lib/deferred');\nconst assign = require('lodash/assign');\nconst forEach = require('lodash/forEach');\nconst debounce = require('lodash/debounce');\nconst isObject = require('lodash/isObject');\nconst isBoolean = require('lodash/isBoolean');\nconst isString = require('lodash/isString');\nconst isNumber = require('lodash/isNumber');\nconst isInteger = require('lodash/isInteger');\nconst defaultsDeep = require('lodash/defaultsDeep');\nconst debug = require('debug')('line:client');\nconst LineError = require('../lib/error');\nconst CloseStatus = require('../lib/closestatus');\n\n\n\n/**\n * Line client class.\n *\n * @class Client\n * @extends {EventEmitterExtra}\n * @param {string=} url Server url, default: `ws://localhost`.\n * @param {Object=} options Options object.\n * @param {Object=} options.handshake Handshake options\n * @param {number=} options.handshake.timeout Handshake timeout duration in milliseconds.\n *      Default: `30000` (30 seconds).\n * @param {any=} options.handshake.payload Handshake payload that will be send to server.\n * @param {number=} options.responseTimeout This is the timeout for getting response from the server\n *      when using `client.send()` method. Default: `10000` (10 seconds). Note that this option is ineffective for\n *      `client.sendWithoutResponse()` method.\n * @param {number=} options.disconnectTimeout In some browsers, `close` frame is not fired immediately.\n *      This timeout is for starting `close` procedure even if close frame is not arrived. Default: `5000` (5 seconds).\n * @param {number=} options.pingInterval Pinging interval. Default: `20000` (20 seconds).\n * @param {boolean=} options.reconnect Whether try to reconnect server after unexpected disconnection,\n *      default `true`.\n * @param {Object=} options.reconnectOptions Reconnection options.\n * @param {number=} options.reconnectOptions.initialDelay In milliseconds. Default: `1000` (1 second).\n * @param {number=} options.reconnectOptions.multiply Default: `1.5`\n * @param {number=} options.reconnectOptions.maxDelay In milliseconds. Default: `30000`\n * @param {number=} options.reconnectOptions.randomness Random delay multiplier. Default: `0.5`\n * @param {boolean=} options.uptime Whether keep & calculate uptime, default `false`.\n *      If this option is not true, `client.getUptime()` returns undefined.\n * @param {Object=} options.uptimeOptions Uptime options.\n * @param {number=} options.uptimeOptions.interval Uptime checking interval. In milliseconds. Default: `5000` (5 seconds).\n * @param {number=} options.uptimeOptions.window Uptime checking window length. In milliseconds. Default: `300000` (5 minutes)\n * @param {boolean=} options.followRedirections Attempt to follow 30X redirections. If this options is set, after\n *      a native websocket connection error, line will try to make a http request to server url. If it is success,\n *      final response url will be used as server after couple of connection attempts. Default: `false`\n * @property {string} url Server url\n * @property {string} id Unique connection id assigned by the server. It will be accessible after handshake.\n * @property {Client.State} state Connection state\n * @example\n * // Add line-client to your html document\n * <script src=\"./node_modules/line-socket/dist/client-web-globals.js\"></script>\n *\n * // For web browsers (consuming as a commonjs module)\n * const LineClient = require('line-socket/client-web');\n *\n * // For node.js\n * const LineClient = require('line-socket/client-node');\n *\n * // Usage\n * const client = new LineClient('ws://localhost:8080');\n * client.connect();\n */\nclass Client extends EventEmitterExtra {\n    constructor(url = 'ws://localhost', options = {}) {\n        super();\n\n        if (!isString(url) || url.trim().length == 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Url parameter must be string and cannot be empty');\n\n        if (!isObject(options))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Options parameter must be an object');\n\n        this.url = url.trim();\n        this.urlFollowed = null;\n        this.options = defaultsDeep(options, {\n            handshake: {\n                timeout: 30000,\n                payload: undefined\n            },\n            responseTimeout: 10000,\n            disconnectTimeout: 5000,\n            pingInterval: 20000,\n            reconnect: true,\n            reconnectOptions: {\n                initialDelay: 1000,\n                multiply: 1.5,\n                maxDelay: 30000,\n                randomness: 0.5\n            },\n            uptime: false,\n            uptimeOptions: {\n                interval: 5000,\n                window: 300000\n            },\n            followRedirections: false\n        });\n\n\n        if (!isObject(this.options.handshake))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.handshake\" must be an object`);\n\n        if (!isInteger(this.options.handshake.timeout) || this.options.handshake.timeout < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.handshake.timeout\" must be a positive integer or zero`);\n\n        try {\n            JSON.stringify(this.options.handshake.payload);\n        } catch (err) {\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.handshake.payload\" must be json friendly, probably circular dependency?`);\n        }\n\n        if (!isInteger(this.options.responseTimeout) || this.options.responseTimeout < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.responseTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.disconnectTimeout) || this.options.disconnectTimeout < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.disconnectTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.pingInterval) || this.options.pingInterval < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.pingInterval\" must be a positive integer or zero`);\n\n        if (!isBoolean(this.options.reconnect))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnect\" must be a boolean`);\n\n        if (!isObject(this.options.reconnectOptions))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions\" must be an object`);\n\n        if (!isInteger(this.options.reconnectOptions.initialDelay) || this.options.reconnectOptions.initialDelay <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.initialDelay\" must be a positive integer`);\n\n        if (!isNumber(this.options.reconnectOptions.multiply) || this.options.reconnectOptions.multiply < 1)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.multiply\" must be a number >= 1`);\n\n        if (!isInteger(this.options.reconnectOptions.maxDelay) || this.options.reconnectOptions.maxDelay <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.maxDelay\" must be a positive integer`);\n\n        if (this.options.reconnectOptions.maxDelay < this.options.reconnectOptions.initialDelay)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.maxDelay\" must be a greater than initial delay`);\n\n        if (!isNumber(this.options.reconnectOptions.randomness) || this.options.reconnectOptions.randomness < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.randomness\" must be a positive number or zero`);\n\n        if (!isBoolean(this.options.uptime))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptime\" must be a boolean`);\n\n        if (!isObject(this.options.uptimeOptions))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions\" must be an object`);\n\n        if (!isInteger(this.options.uptimeOptions.interval) || this.options.uptimeOptions.interval <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions.interval\" must be a positive integer`);\n\n        if (!isInteger(this.options.uptimeOptions.window) || this.options.uptimeOptions.window <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions.window\" must be a positive integer`);\n\n        if (this.options.uptimeOptions.window < this.options.uptimeOptions.interval)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions.window\" must be a greater than interval`);\n\n        if (!isBoolean(this.options.followRedirections))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.followRedirections\" must be a boolean`);\n\n        this.ws_ = null;\n        this.id = null;\n        this.state = Client.State.READY;\n\n        this.reconnectState_ = {disabled: false, attempt: 0, timeout: null};\n        this.deferreds_ = {};\n        this.disconnectTimeout_ = null;\n        this.uptimeBuffer_ = [];\n        this.uptimeBufferLength_ = Math.round(this.options.uptimeOptions.window / this.options.uptimeOptions.interval);\n        this.uptimeInterval_ = options.uptime ? setInterval(this.uptimeTick_.bind(this), this.options.uptimeOptions.interval) : null;\n        this.autoPing_ = debounce(() => {});\n\n        if (this.options.pingInterval > 0) {\n            this.autoPing_ = debounce(() => {\n                this\n                    .ping()\n                    .then(() => {\n                        // Ping successfull. If we still connected, debounce next one!\n                        if (this.options.pingInterval > 0 && this.state == Client.State.CONNECTED) {\n                            this.autoPing_(); // Recursive\n                        }\n                    })\n                    .catch(() => { /* ping() method handles disconnection the logic itself */ });\n            }, this.options.pingInterval);\n        }\n    }\n\n\n    /**\n     * Starts the connection procedure.\n     *\n     * If server url is invalid or there is a security error,\n     * this method will throw `Client.ErrorCode.WEBSOCKET_ERROR`.\n     *\n     * When procedure is started, `Client.Event.CONNECTING` event will be emitted.\n     *\n     * If an error occured during connection or handshake, the client will emit `Client.Event.CONNECTING_ERROR`.\n     *\n     * If connection is failed for some reason and `options.reconnect` is `true`. The client will\n     * retry to connect.\n     *\n     * @returns {boolean}\n     * @example\n     * client.connect();\n     *\n     * client.on(Client.Event.CONNECTED, () => {\n     *   console.log('Client connected.');\n     * });\n     *\n     * client.on(Client.Event.CONNECTING_ERROR, (err) => {\n     *   console.log('Could not connect!', err);\n     * });\n     */\n    connect() {\n        switch (this.state) {\n            case Client.State.DISCONNECTED:\n            case Client.State.READY:\n                let url = this.url;\n\n                if (this.options.followRedirections && this.urlFollowed) {\n                    url = this.urlFollowed;\n                    debug(`Following redirection \"${this.url}\" -> \"${this.urlFollowed}\"`);\n                }\n\n                debug(`Connecting to \"${url}\" ...`);\n\n                try {\n                    this.reconnectState_.disabled = false;\n                    this.ws_ = new WebSocket(url);\n                    this.bindEvents_();\n                    this.state = Client.State.CONNECTING;\n                    this.emit(Client.Event.CONNECTING);\n                    return true;\n                } catch (err) {\n                    throw new LineError(\n                        Client.ErrorCode.WEBSOCKET_ERROR,\n                        `Native websocket error. Invalid url or security error`,\n                        err\n                    );\n                }\n\n            default:\n                debug(`Ignoring connect() call, client is in \"${this.state}\" state`);\n                return false;\n        }\n    }\n\n\n    /**\n     * TODO: This is an experimental method currently, it's just used in tests.\n     * DO NOT use in production.\n     *\n     * @returns {Promise}\n     * @ignore\n     */\n    connectAsync() {\n        return new Promise((resolve, reject) => {\n            this.connect(); // Can throw WEBSOCKET_ERROR or ignore silently\n\n            let removeListeners = () => {};\n\n            const onConnectingError = (err) => {\n                removeListeners();\n                reject(err);\n            };\n\n            const onConnected = (data) => {\n                removeListeners();\n                resolve(data);\n            };\n\n            const onDisconnected = (e) => {\n                removeListeners();\n                reject(new LineError(Client.ErrorCode.DISCONNECTED, `Client disconnected`, e));\n            };\n\n            removeListeners = () => {\n                this.removeListener(Client.Event.CONNECTING_ERROR, onConnectingError);\n                this.removeListener(Client.Event.CONNECTED, onConnected);\n                this.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n            }\n\n            this.once(Client.Event.CONNECTING_ERROR, onConnectingError);\n            this.once(Client.Event.CONNECTED, onConnected);\n            this.once(Client.Event.DISCONNECTED, onDisconnected);\n        });\n    }\n\n\n    /**\n     * Gracefully closes the connection. This method can throw `Client.ErrorCode.WEBSOCKET_ERROR` if\n     * provided parameters are invalid. If websocket is not closed after `options.disconnectTimeout` ms,\n     * the client will start the disconnection procedure forcefully.\n     *\n     * @param {number=} code A numeric value indicating the status code explaining why the connection is being closed.\n     *      Must be between 1000-4999. Default is 1000.\n     * @param {any=} reason A human-readable string explaining why the connection is closing. This string must\n     *      be no longer than 123 bytes of UTF-8 text (not characters).\n     * @param {boolean=} opt_retry Whether retry to connect after disconnection.\n     * @returns {boolean}\n     * @example\n     * client.disconnect();\n     *\n     * client.on(Client.Event.DISCONNECTED, (e) => {\n     *   console.log('Disconnected', e.code, e.reason);\n     * });\n     */\n    disconnect(code, reason, opt_retry) {\n        switch (this.state) {\n            case Client.State.CONNECTING:\n            case Client.State.HANDSHAKING:\n            case Client.State.CONNECTED:\n                debug(`Disconnecting... (State: ${this.state})`);\n\n                try {\n                    this.ws_.close(code || 1000, reason); // Can throw INVALID_ACCESS_ERR, SYNTAX_ERR\n                    debug(`Websocket is closed`);\n                    this.reconnectState_.disabled = !opt_retry;\n                    this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Disconnect procedure started'));\n                    this.autoPing_.cancel();\n\n                    // Wait \"close\" event for some time, then manually start onClose procedure\n                    if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n                    if (this.options.disconnectTimeout) {\n                        this.disconnectTimeout_ = setTimeout(() => {\n                            debug(`Disconnect timeout exceeded, force disconnecting...`);\n\n                            this.emit(Client.Event.ERROR, new LineError(\n                                Client.ErrorCode.DISCONNECT_TIMEOUT,\n                                'Disconnect timeout exceeded, force disconnecting...'\n                            ));\n\n                            this.onClose_(CloseStatus.DISCONNECT_TIMEOUT);\n\n                            clearTimeout(this.disconnectTimeout_);\n                        }, this.options.disconnectTimeout);\n                    }\n\n                    this.state = Client.State.DISCONNECTING;\n                    this.emit(Client.Event.DISCONNECTING);\n\n                    return true;\n                } catch (err) {\n                    throw new LineError(\n                        Client.ErrorCode.WEBSOCKET_ERROR,\n                        'Could not disconnect. Invalid code or reason, check payload.',\n                        err\n                    );\n                }\n\n            default:\n                debug(`Ignoring disconnect() call, client is in \"${this.state}\" state.`);\n                return false;\n        }\n    }\n\n\n    /**\n     * TODO: This is an experimental method currently, it's just used in tests.\n     * DO NOT use in production.\n     *\n     * @returns {Promise}\n     * @ignore\n     */\n    disconnectAsync(code, reason, retry) {\n        return new Promise((resolve, reject) => {\n            this.disconnect(code, reason, retry); // Can throw WEBSOCKET_ERROR or ignore silently\n\n            const onDisconnected = (e) => {\n                // this.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n                resolve(e);\n            };\n\n            this.once(Client.Event.DISCONNECTED, onDisconnected);\n        });\n    }\n\n\n    /**\n     * Binds websocket events\n     *\n     * @ignore\n     */\n    bindEvents_() {\n        debug('Binding native event handlers.');\n        this.ws_.onopen = this.onOpen_.bind(this);\n        this.ws_.onclose = this.onClose_.bind(this);\n        this.ws_.onerror = this.onError_.bind(this);\n        this.ws_.onmessage = this.onMessage_.bind(this);\n    }\n\n\n    /**\n     * Unbinds websocket events\n     *\n     * @ignore\n     */\n    unBindEvents_() {\n        if (!this.ws_) return;\n        debug('Unbinding native event handlers.');\n        this.ws_.onopen = function() {};\n        this.ws_.onclose = function() {};\n        this.ws_.onerror = function() {};\n        this.ws_.onmessage = function() {};\n    }\n\n\n    /**\n     * Native \"open\" event handler. At this time we will start the handshakin process.\n     *\n     * @ignore\n     */\n    onOpen_() {\n        debug('Native \"open\" event received, starting handshake process');\n\n        this.state = Client.State.HANDSHAKING;\n        const message = new Message({\n            name: Message.Name.HANDSHAKE,\n            payload: this.options.handshake.payload // We're sure that this is json friendly\n        });\n\n        this\n            .send_(message, this.options.handshake.timeout)\n            .then(data => {\n                // Message is sent and we got the response!\n                if (!isObject(data)) {\n                    debug('Unexpected handshake response!?');\n\n                    this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                        Client.ErrorCode.HANDSHAKE_ERROR,\n                        'Handshake response is not object. Aborting handshake...',\n                        data\n                    ));\n\n                    this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, unexpected handshake response.', true);\n                    return;\n                }\n\n                debug('Handshake successful.');\n                this.resetReconnectState_();\n                this.id = data.id;\n                this.state = Client.State.CONNECTED;\n                this.autoPing_(); // Start auto-ping\n\n                debug('Emitting \"connected\" event...');\n                this.emit(Client.Event.CONNECTED, data.payload);\n            })\n            .catch(err => {\n                if (err instanceof LineError) {\n                    switch (err.code) {\n                        case Client.ErrorCode.DISCONNECTED:\n                            debug('Handshake failed, connection lost (disconnected)');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_ERROR,\n                                `Connection lost during handshake.`\n                            ));\n                            return;\n\n                        case Client.ErrorCode.MESSAGE_TIMEOUT:\n                            // TODO: Try again maybe?\n                            debug('Handshake failed, message timeout');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_ERROR,\n                                'Handshake failed, request timeout.'\n                            ));\n                            return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, request timeout.', true);\n\n                        case Client.ErrorCode.MESSAGE_REJECTED:\n                            debug('Handshake REJECTED!');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_REJECTED,\n                                'Handshake rejected, check payload for further details.',\n                                err && err.payload\n                            ));\n                            return this.disconnect(CloseStatus.HANDSHAKE_REJECTED.code, 'Handshake rejected', true);\n\n                        case Client.ErrorCode.WEBSOCKET_ERROR:\n                            debug('Handshake failed, native websocket error');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_ERROR,\n                                `Handshake failed. Websocket protocol error, check payload.`,\n                                err && err.payload\n                            ));\n                            return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, native websocket error', true);\n\n                        default:\n                            debug('Handshake failed, unknown line error', err);\n                            return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown line error', true);\n                    }\n                }\n\n                // Unknown error\n                debug('Handshake failed, unknown error', err);\n                return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown error', true);\n            });\n    }\n\n\n    /**\n     * Native \"close\" event handler.\n     *\n     * @param {Event} closeEvent Native close event.\n     * @param {number} closeEvent.code Close status code sent by server.\n     * @param {string=} closeEvent.reason Human readable close reason.\n     * @ignore\n     */\n    onClose_(closeEvent) {\n        debug(`Native \"close\" event received in \"${this.state}\" state (code: ${closeEvent.code}, reason: ${closeEvent.reason})`);\n\n        if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n        this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Client is disconnected'));\n        this.unBindEvents_();\n        this.autoPing_.cancel();\n\n        this.id = null;\n        this.ws_ = null;\n\n        debug('Emitting \"disconnected\" event...');\n        this.state = Client.State.DISCONNECTED;\n        this.emit(Client.Event.DISCONNECTED, closeEvent);\n\n        if (this.options.reconnect && !this.reconnectState_.disabled) {\n            let timeout = this.options.reconnectOptions.initialDelay *\n                Math.max(this.options.reconnectOptions.multiply * this.reconnectState_.attempt, 1);\n            timeout = Math.min(timeout, this.options.reconnectOptions.maxDelay);\n            timeout += Math.round(Math.random() * this.options.reconnectOptions.randomness * timeout);\n\n            debug(`Will try to reconnect in ${timeout} ms`);\n\n            this.reconnectState_.timeout && clearTimeout(this.reconnectState_.timeout);\n            this.reconnectState_.timeout = setTimeout(() => {\n                this.reconnectState_.attempt++;\n                this.connect();\n            }, timeout);\n        }\n    }\n\n\n    /**\n     * Native \"error\" handler. A \"close\" event will ALWAYS follow this event.\n     * See: https://www.w3.org/TR/websockets/#closeWebSocket\n     * So, if client state is connecting/handshaking, emit `CONNECTING_ERROR`.\n     *\n     * @param {Error} err Native error object.\n     * @ignore\n     */\n    onError_(err) {\n        debug(`Native \"error\" event received in \"${this.state}\" state.`);\n        let eventName = Client.Event.ERROR;\n\n        if (this.state == Client.State.CONNECTING || this.state == Client.State.HANDSHAKING) {\n            eventName = Client.Event.CONNECTING_ERROR;\n        }\n\n        this.emit(eventName, new LineError(\n            Client.ErrorCode.WEBSOCKET_ERROR,\n            `Native websocket error occured, check payload.`,\n            err\n        ));\n\n        // For 30X redirects, we get this error: \"Unexpected response code: 30X\"\n        // Attempt to make a http request to server url (this request will follow redirections).\n        // If it is successful, use the final response url as websocket url\n        if (this.options.followRedirections) {\n            debug('Attempting to follow redirections...');\n            const httpUrl = Client.ws2http(this.url);\n\n            if (httpUrl) {\n                debug(`Making a request to \"${httpUrl}\" for following`);\n                Client\n                    .fetchResponseUrl(httpUrl)\n                    .then((httpUrlFollowed) => {\n                        const wsUrl = Client.http2ws(httpUrlFollowed);\n                        if (!wsUrl) return debug(`Could not convert http url \"${httpUrlFollowed}\" to ws`);\n                        if (this.urlFollowed == wsUrl) return;\n                        debug(`Updating followed url to \"${wsUrl}\"`);\n                        this.urlFollowed = wsUrl;\n                    })\n                    .catch(err => debug('Could not follow redirection, ignoring...', err));\n            } else {\n                debug(`Could not convert ws url to http`);\n            }\n        }\n    }\n\n\n    /**\n     * Native \"message\" handler.\n     *\n     * @param {Event} e Native message event.\n     * @param {string} e.data Raw message data.\n     * @ignore\n     */\n    onMessage_(e) {\n        debug(`Native \"message\" event received in \"${this.state}\" state.`);\n        let message;\n\n        // A message is recieved, debounce our auto-ping handler\n        if (this.state == Client.State.CONNECTED) {\n            this.autoPing_();\n        }\n\n        /**\n         * Try to parse incoming message\n         */\n        try {\n            message = Message.parse(e.data);\n        } catch (err) {\n            debug('Could not parse message', e.data);\n            this.emit(Client.Event.ERROR, new LineError(\n                Client.ErrorCode.INVALID_JSON,\n                'Could not parse incoming message, invalid json. Check payload for incoming data.',\n                e.data\n            ));\n            return;\n        }\n\n        /**\n         * Route the incoming message\n         */\n        if (message.name == Message.Name.PING) { // Ping message arrived\n            this.onPingMessage_(message);\n        } else if (message.name == Message.Name.RESPONSE) { // Response message arrive\n            this.onResponseMessage_(message);\n        } else if (Message.ReservedNames.indexOf(message.name) == -1) { // If message name is not reserved\n            if (!message.id) { // A message arrived without response\n                this.onMessageWithoutResponse_(message);\n            } else { // A message arrived awaiting its response\n                this.onMessageWithResponse_(message);\n            }\n        } else {\n            debug(`Could not route the message`, message);\n        }\n    }\n\n\n    /**\n     * On \"ping\" message handler. Respond with \"pong\".\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onPingMessage_(message) {\n        debug('Ping received, responding \"pong\"...');\n\n        this\n            .sendWithoutResponse_(message.createResponse(null, 'pong'))\n            .catch(err => debug('Ping response failed to send back, ignoring for now...', err));\n    }\n\n\n    /**\n     * A response is arrived, find the related deferred and finalize it.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onResponseMessage_(message) {\n        const deferred = this.deferreds_[message.id];\n\n        if (!deferred)\n            return debug(`Unknown message response, ignoring... (name=\"${message.name}\" id=\"${message.id}\")`);\n\n        debug(`Message response arrived: name=\"${message.name}\" id=\"${message.id}\"`);\n\n        if (message.err) {\n            // Server rejects the message\n            deferred.reject(new LineError(\n                Client.ErrorCode.MESSAGE_REJECTED,\n                'Message is rejected by server, check payload.',\n                message.err\n            ));\n        } else {\n            // Server resolves the message\n            deferred.resolve(message.payload);\n        }\n\n        delete this.deferreds_[message.id];\n    }\n\n\n    /**\n     * A message is arrived without awaiting a response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithoutResponse_(message) {\n        debug(`Message without response: name=\"${message.name}\"`);\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * A message is arrived and server is waiting for a response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithResponse_(message) {\n        debug(`Message with response: name=\"${message.name}\" id=\"${message.id}\"`);\n\n        message.once('resolved', (payload) => {\n            debug(`Client resolving: name=\"${message.name}\" id=\"${message.id}\"`);\n\n            // Try to send our response back to server, if not emit an error\n            this\n                .sendWithoutResponse_(message.createResponse(null, payload))\n                .catch((err) => {\n                    this.emit(Client.Event.ERROR, new LineError(\n                        Client.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (resolve)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        message.once('rejected', (err) => {\n            debug(`Client rejecting: name=\"${message.name}\" id=\"${message.id}\"`);\n\n            // Try to send our response back to server, if not emit an error\n            this\n                .sendWithoutResponse_(message.createResponse(err))\n                .catch((err) => {\n                    this.emit(Client.Event.ERROR, new LineError(\n                        Client.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (reject)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * Sends a message to server with awaiting its response. This method returns a promise\n     * which resolves the payload parameter will be passed into `message.resolve(...)` in server-side.\n     *\n     * If server rejects the message with `message.reject(...)`, this promise will be rejected with\n     * `Client.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n     * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {string} name Message name.\n     * @param {any=} payload Optional message payload.\n     * @param {number=} timeout Timeout duration for waiting the response. If this parameter\n     *      is not provided, `options.responseTimeout` will be used.\n     * @returns {Promise}\n     * @example\n     * client\n     *   .send('hello', {some: 'payload'})\n     *   .then((data) => {\n     *     console.log('Sent and got the response', data);\n     *   })\n     *   .catch((err) => {\n     *     if (err.code == Client.ErrorCode.MESSAGE_REJECTED) {\n     *       console.log('Message rejected by server', err.payload);\n     *     } else if (err.code == Client.ErrorCode.MESSAGE_TIMEOUT) {\n     *       console.log('Server did not responded, timeout exceeded');\n     *     } else {\n     *       console.log('Could not send message', err);\n     *     }\n     *   });\n     */\n    send(name, payload, opt_timeout) { // This method is for external usage!\n        if (this.state != Client.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                Client.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload});\n            return this.send_(message, opt_timeout);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                Client.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Sends a message to server without waiting its response. This method returns a promise\n     * that resolves with nothing if the message is successfully sent.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {string} name\n     * @param {any=} payload\n     * @returns {Promise}\n     * @example\n     * client\n     *   .sendWithoutResponse('hello', {some: data})\n     *   .then(() => {\n     *     console.log('Message is sent');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Could not send message');\n     *   });\n     */\n    sendWithoutResponse(name, payload) { // This method is for external usage!\n        if (this.state != Client.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                Client.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload}); // Can throw Message.ErrorCode.INVALID_JSON\n            return this.sendWithoutResponse_(message);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                Client.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Base method for sending a message with timeout. Please favor this method internally\n     * instead of using `send` method.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n     * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {Message} message\n     * @param {number=} opt_timeout\n     * @returns {Promise}\n     * @ignore\n     */\n    send_(message, opt_timeout) {\n        const timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.options.responseTimeout;\n        message.setId();\n\n        const deferred = this.deferreds_[message.id] = new Deferred({\n            onExpire: () => {\n                delete this.deferreds_[message.id];\n            },\n            timeout: timeout\n        });\n\n        return this\n            .sendWithoutResponse_(message)\n            .then(() => deferred)\n            .catch((err) => {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(\n                        Client.ErrorCode.MESSAGE_TIMEOUT,\n                        `Message timeout! Its response did not recived after ${timeout} ms`\n                    );\n                }\n\n                throw err;\n            });\n    }\n\n\n    /**\n     * Base method for sending a message without response. Please favor this method internally\n     * instead of using `sendWithoutResponse` method.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {Message} message\n     * @returns {Promise}\n     * @ignore\n     */\n    sendWithoutResponse_(message) {\n        if (!this.ws_ || this.ws_.readyState != 1) {\n            return Promise.reject(new LineError(\n                Client.ErrorCode.DISCONNECTED,\n                `Could not send message, there is no open connection.`\n            ));\n        }\n\n        return new Promise((resolve, reject) => {\n            const messageStr = message.toString();\n\n            try {\n                debug(`Sending message: ${messageStr}`);\n                this.ws_.send(messageStr); // Can throw INVALID_STATE_ERR, SYNTAX_ERR\n                resolve();\n            } catch (err) {\n                reject(new LineError(\n                    Client.ErrorCode.WEBSOCKET_ERROR,\n                    'Could not send message. Either socket is not connected or syntax error, check payload.',\n                    err\n                ));\n            }\n        });\n    }\n\n\n    /**\n     * Sends a ping message to server, if it's failed, the connection\n     * will be closed and will retry to connect again. Server and client ping each\n     * other automatically with an interval.\n     *\n     * @returns {Promise}\n     */\n    ping() {\n        const currentSocket = this.ws_;\n\n        debug('Pinging...');\n        return this\n            .send_(new Message({name: Message.Name.PING}))\n            .catch(err => {\n                // If socket is changed, dismiss\n                if (this.ws_ != currentSocket) {\n                    debug('Auto-ping failed, but socket is also changed, dismissing...');\n                    return;\n                }\n\n                // No matter what error is, start disconnection process\n                debug('Auto-ping failed, manually disconnecting...');\n                this.disconnect(CloseStatus.PING_FAILED.code, 'Auto ping failed', true);\n                throw new LineError(Client.ErrorCode.PING_ERROR, `Ping failed, disconnecting...`, err);\n            });\n    }\n\n\n    /**\n     * On uptime tick event handler. Check current state and push a marker to buffer.\n     *\n     * @ignore\n     */\n    uptimeTick_() {\n        debug('Uptime Tick');\n        this.uptimeBuffer_.push(this.state == Client.State.CONNECTED);\n\n        if (this.uptimeBuffer_.length > this.uptimeBufferLength_) {\n            this.uptimeBuffer_.splice(0, this.uptimeBufferLength_ - this.uptimeBuffer_.length);\n        }\n    }\n\n\n    /**\n     * Calculates (connection) uptime for last `options.uptime.window` (default 5 minutes)\n     * with `options.uptime.interval` (default 5 seconds) interval. Returns a number between\n     * 0 and 1. If `options.uptime` is false, this method returns nothing.\n     *\n     * @returns {number?}\n     */\n    getUptime() {\n        if (!this.options.uptime) return;\n        if (this.uptimeBuffer_.length == 0) return 0;\n        return this.uptimeBuffer_.filter(val => val).length / this.uptimeBuffer_.length;\n    }\n\n\n    /**\n     * Disposes the client.\n     *\n     * @returns {Promise}\n     */\n    dispose() {\n        return new Promise((resolve) => {\n            debug('Disposing...');\n\n            switch (this.state) {\n                case Client.State.CONNECTING:\n                case Client.State.HANDSHAKING:\n                case Client.State.CONNECTED:\n                    this.once(Client.Event.DISCONNECTED, () => {\n                        this.removeAllListeners();\n                        this.uptimeBuffer_ = [];\n                        if (this.uptimeInterval_) clearInterval(this.uptimeInterval_);\n                        debug('Disposed!');\n                        resolve();\n                    });\n\n                    this.disconnect(CloseStatus.DISPOSED.code, CloseStatus.DISPOSED.reason);\n                    break;\n\n                case Client.State.READY:\n                case Client.State.DISCONNECTING:\n                case Client.State.DISCONNECTED:\n                    this.resetReconnectState_();\n                    this.removeAllListeners();\n                    this.uptimeBuffer_ = [];\n                    if (this.uptimeInterval_) clearInterval(this.uptimeInterval_);\n                    debug('Disposed!');\n                    resolve();\n                    break;\n            }\n        });\n    }\n\n\n    /**\n     * Reject all the awaiting deferred with given error.\n     *\n     * @param {Error} err An error object to reject all awaiting deferreds.\n     * @ignore\n     */\n    rejectAllDeferreds_(err) {\n        forEach(this.deferreds_, deferred => deferred.reject(err));\n        this.deferreds_ = {};\n    }\n\n\n    /**\n     * Resets the reconnection state.\n     *\n     * @ignore\n     */\n    resetReconnectState_() {\n        debug('Resetting reconnection state...');\n        if (this.reconnectState_.timeout) clearTimeout(this.reconnectState_.timeout);\n        this.reconnectState_ = {disabled: false, attempt: 0, timeout: null};\n    }\n}\n\n\nClient.ws2http = function(url) {\n    let rv;\n    const mapping = {\n        'ws://': 'http://',\n        'wss://': 'https://'\n    };\n    forEach(mapping, (replace, target) => {\n        if (url.indexOf(target) != 0) return;\n        rv = replace + url.substr(target.length);\n    });\n    return rv;\n};\n\n\nClient.http2ws = function(url) {\n    let rv;\n    const mapping = {\n        'http://': 'ws://',\n        'https://': 'wss://'\n    };\n    forEach(mapping, (replace, target) => {\n        if (url.indexOf(target) != 0) return;\n        rv = replace + url.substr(target.length);\n    });\n    return rv;\n};\n\n\nClient.fetchResponseUrl = function(url, timeout = 3000) {\n    return new Deferred({\n        timeout,\n        handler: (deferred) => {\n            const req = new XMLHttpRequest();\n            req.addEventListener('error', () => deferred.reject(new Error('Native XMLHttpRequest error')));\n            req.addEventListener('abort', () => deferred.reject(new Error('Aborted XMLHttpRequest')));\n            req.addEventListener('load', () => deferred.resolve(req.responseURL));\n            req.open('HEAD', url);\n\n            try {\n                req.send();\n            } catch (err) {\n                deferred.reject(err);\n            }\n        }\n    });\n};\n\n\n// Expose internal classes\nClient.Message = Message;\nClient.Error = LineError;\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.ErrorCode = {\n    /**\n     * When constructing `new Client()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'cInvalidOptions',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'cInvalidJSON',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates an operational error during the handshake. If `options.reconnect` is true,\n     * the client will try to reconnect again.\n     */\n    HANDSHAKE_ERROR: 'cHandshakeError',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates that server is explicitly rejected the handshake, which probably means\n     * client's handshake payload is not accepted by server.\n     */\n    HANDSHAKE_REJECTED: 'cHandshakeRejected',\n    /**\n     * This error can be seen in rejection of `client.send()` method. This means the\n     * message is reached to server but the timeout is exceeded.\n     */\n    MESSAGE_TIMEOUT: 'cMessageTimeout',\n    /**\n     * This error can be seen in rejection of `client.send()` method, which again indicates that\n     * server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'cMessageRejected',\n    /**\n     * When the response of a message failed to send to server, this error\n     * will be emitted in `Client.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * This error is for native websocket errors. Native error is wrapped by `LineError`\n     * and can be accessible under `err.payload`.\n     */\n    WEBSOCKET_ERROR: 'cWebsocketError',\n    /**\n     * When disconnect timeout is exceed, this error will be emited in\n     * `Client.Events.ERROR` event. After this event, the disconnect\n     * procedure will be started forcefully.\n     */\n    DISCONNECT_TIMEOUT: 'cDisconnectError',\n    /**\n     * This error can be seen in rejection of `client.ping()` method. After this error,\n     * client will be disconnected.\n     */\n    PING_ERROR: 'cPingError',\n    /**\n     * This error indicates the action is prohibited because client is not\n     * in connected state or connection is closing.\n     */\n    DISCONNECTED: 'cDisconnected'\n};\n\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.State = {\n    /**\n     * `ready`\n     */\n    READY: 'ready',\n    /**\n     * `connecting`\n     */\n    CONNECTING: 'connecting',\n    /**\n     * `handshaking`\n     */\n    HANDSHAKING: 'handshaking',\n    /**\n     * `connected`\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnecting`\n     */\n    DISCONNECTING: 'disconnecting',\n    /**\n     * `disconnected`\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.Event = {\n    /**\n     * `_connecting`\n     */\n    CONNECTING: '_connecting',\n    /**\n     * `_connecting_error`\n     */\n    CONNECTING_ERROR: '_connecting_error',\n    /**\n     * `_connected`\n     */\n    CONNECTED: '_connected',\n    /**\n     * `_disconnecting`\n     */\n    DISCONNECTING: '_disconnecting',\n    /**\n     * `_disconnected`\n     */\n    DISCONNECTED: '_disconnected',\n    /**\n     * `_error`\n     */\n    ERROR: '_error'\n};\n\n\nmodule.exports = Client;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/client-web.js","module.exports = require(\"request\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"request\"\n// module id = 7\n// module chunks = 0","module.exports = require(\"ws\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ws\"\n// module id = 8\n// module chunks = 0","module.exports = {\n    INTERNAL_ERROR: {code: 4200, reason: 'Internal error'},\n    PING_FAILED: {code: 4201, reason: 'Ping failed'},\n    HANDSHAKE_FAILED: {code: 4202, reason: 'Handshake failed'},\n    HANDSHAKE_REJECTED: {code: 4203, reason: 'Handshake rejected'},\n    DISCONNECT_TIMEOUT: {code: 4204, reason: 'Disconnect timeout'},\n    DISPOSED: {code: 4205, reason: 'Client disposed'},\n    UNKNOWN_ERROR: {code: 4299, reason: 'Unknown error'},\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/closestatus.js","const isUndefined = require('lodash/isUndefined');\nconst isString = require('lodash/isString');\nconst isObject = require('lodash/isObject');\nconst isFunction = require('lodash/isFunction');\nconst values = require('lodash/values');\nconst assign = require('lodash/assign');\nconst {generateDummyId} = require('./utils');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst LineError = require('./error');\n\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\nclass Message extends EventEmitterExtra {\n    static parse(raw) {\n        try {\n            const data = JSON.parse(raw);\n\n            // If error is error-like object, construct real error\n            if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                data.e = assign(new Error(), data.e);\n            }\n\n            return new Message({\n                name: data.n,\n                payload: data.p,\n                err: data.e,\n                id: data.i\n            });\n        } catch(err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, `Could not parse incoming message.`);\n        }\n    }\n\n\n    constructor({name, payload, id, err}) {\n        super();\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message payload or error must be json-friendly. Maybe circular json?`\n            );\n        }\n\n        this.name = name;\n        this.payload = payload;\n        this.id = id;\n        this.err = err;\n\n        this.isResponded_ = false;\n    }\n\n\n    setId(id = generateDummyId()) {\n        this.id = id;\n        return id;\n    }\n\n\n    createResponse(err, payload) {\n        return new Message({name: '_r', payload, err, id: this.id});\n    }\n\n\n    /**\n     * Resolves the message with sending a response back. If the source\n     * does not expecting a response, you don't need to call these methods.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} payload\n     */\n    resolve(payload) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be resolved (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n        try {\n            JSON.stringify(payload);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('resolved', payload);\n    }\n\n\n    /**\n     * Rejects the message, with sending error response back to the source.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} err\n     */\n    reject(err) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be rejected (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n\n        try {\n            JSON.stringify(err);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('rejected', err);\n    }\n\n\n    toString() {\n        const data = {n: this.name};\n\n        if (!isUndefined(this.payload))\n            data.p = this.payload;\n\n        if (!isUndefined(this.id))\n            data.i = this.id;\n\n        if (!isUndefined(this.err)) {\n            data.e = this.err instanceof Error ? assign({\n                name: this.err.name,\n                message: this.err.message\n            }, this.err) : this.err;\n        }\n\n        // We're sure the data is json-friendly\n        return JSON.stringify(data);\n    }\n\n\n    dispose() {\n        const events = this.eventNames();\n        events.forEach(event => this.removeAllListeners(event));\n    }\n}\n\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\n\nMessage.ReservedNames = values(Message.Name);\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded',\n};\n\n\nmodule.exports = Message;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/message.js","const assign = require('lodash/assign');\n\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId(length = 4) {\n    return (\"0000\" + (Math.random()*Math.pow(36,length) << 0).toString(36)).slice(-length);\n}\n\n\nmodule.exports = {generateDummyId};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/utils.js","module.exports = require(\"debug\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"debug\"\n// module id = 12\n// module chunks = 0","module.exports = require(\"lodash/debounce\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/debounce\"\n// module id = 13\n// module chunks = 0","module.exports = require(\"lodash/defaultsDeep\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/defaultsDeep\"\n// module id = 14\n// module chunks = 0","module.exports = require(\"lodash/forEach\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/forEach\"\n// module id = 15\n// module chunks = 0","module.exports = require(\"lodash/isBoolean\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isBoolean\"\n// module id = 16\n// module chunks = 0","module.exports = require(\"lodash/isFunction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isFunction\"\n// module id = 17\n// module chunks = 0","module.exports = require(\"lodash/isInteger\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isInteger\"\n// module id = 18\n// module chunks = 0","module.exports = require(\"lodash/isNumber\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isNumber\"\n// module id = 19\n// module chunks = 0","module.exports = require(\"lodash/isUndefined\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isUndefined\"\n// module id = 20\n// module chunks = 0","module.exports = require(\"lodash/values\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/values\"\n// module id = 21\n// module chunks = 0","global.WebSocket = require('ws'); // Polyfill for extending browser code\nconst Client = require('./client-web');\nconst request = require('request');\nconst Deferred = require('../lib/deferred');\n\n\n/**\n * Polyfill http request for node\n */\nClient.fetchResponseUrl = function(url, timeout = 3000) {\n    return new Deferred({\n        timeout,\n        handler: (deferred) => {\n            request\n                .head(url, {followRedirect: false})\n                .on('response', (response) => {\n                    if (response.statusCode != 301 && response.statusCode != 302) {\n                        return deferred.reject(new Error(`Not redirected, status code: \"${response.statusCode}\"`));\n                    }\n\n                    if (!response.headers.location) {\n                        return deferred.reject(new Error(`Redirected, but no location header`));\n                    }\n\n                    deferred.resolve(response.headers.location);\n                })\n                .on('error', err => deferred.reject(err));\n        }\n    });\n};\n\n\nmodule.exports = Client;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/client-node.js"],"sourceRoot":""}