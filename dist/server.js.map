{"version":3,"sources":["webpack:///server.js","webpack:///webpack/bootstrap f1e4d16c0b29e70e349b","webpack:///./src/lib/error.js","webpack:///external \"lodash/assign\"","webpack:///./src/lib/message.js","webpack:///external \"debug\"","webpack:///external \"event-emitter-extra\"","webpack:///external \"lodash/forEach\"","webpack:///external \"lodash/isInteger\"","webpack:///external \"lodash/isObject\"","webpack:///./src/server/connection.js","webpack:///./src/server/rooms.js","webpack:///external \"uws\"","webpack:///external \"ws\"","webpack:///./src/lib/closestatus.js","webpack:///./src/lib/deferred.js","webpack:///./src/lib/utils.js","webpack:///./src/server/room.js","webpack:///external \"lodash/clone\"","webpack:///external \"lodash/debounce\"","webpack:///external \"lodash/filter\"","webpack:///external \"lodash/isFunction\"","webpack:///external \"lodash/isString\"","webpack:///external \"lodash/isUndefined\"","webpack:///external \"lodash/map\"","webpack:///external \"lodash/values\"","webpack:///external \"uuid\"","webpack:///./src/server/server.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__esModule","o","object","property","prototype","hasOwnProperty","p","s","LineError","code","message","payload","this","stack","Error","require","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","isUndefined","isString","isObject","values","assign","_require","generateDummyId","EventEmitterExtra","Message","_EventEmitterExtra","_ref","id","err","_this","getPrototypeOf","JSON","stringify","ErrorCode","INVALID_JSON","isResponded_","raw","data","parse","e","arguments","undefined","MISSING_ID","ALREADY_RESPONDED","err_","emit","_this2","events","eventNames","forEach","event","removeAllListeners","Name","RESPONSE","HANDSHAKE","PING","ReservedNames","isInteger","debounce","Deferred","uuid","Debug","CloseStatus","debug","ServerConnection","socket","server","v4","state","State","AWAITING_HANDSHAKE","deferreds_","autoPing_","on","onMessage_","bind","onError_","onClose_","idleTimeout","idleTimeoutDuration","options","pingInterval","timeout","rejectOnExpire","onExpire","persistsInRoot","rooms","root","getConnectionById","belongingRooms","getRooms","readyState","removeFromAll","remove","DISCONNECTED","Event","IDLE_TIMEOUT","ping","then","delay","CONNECTED","catch","handshakeTimeout","handshakeTimeout_","setTimeout","close","HANDSHAKE_FAILED","flags","ERROR","onHandshakeMessage_","onPingMessage_","onResponseMessage_","indexOf","onMessageWithResponse_","onMessageWithoutResponse_","sendWithoutResponse_","createResponse","once","clearTimeout","responsePayload","add","WEBSOCKET_ERROR","reason","dispose","HANDSHAKE_REJECTED","handshakeListener","resolve","deferred","MESSAGE_REJECTED","reject","_this3","MESSAGE_NOT_RESPONDED","cancel","rejectAllDeferreds_","newId","HANDSHAKE_ENDED","ID_CONFLICT","roomName","getRoomsOf","opt_timeout","Promise","send_","_this4","responseTimeout","setId","EXPIRED","MESSAGE_TIMEOUT","_this5","messageStr","toString","send","_this6","PING_FAILED","PING_ERROR","_this7","filter","map","Room","Rooms","connection","getConnectionsCount","room","INTERNAL_ERROR","DISCONNECT_TIMEOUT","DISPOSED","UNKNOWN_ERROR","_ref$handler","handler","_ref$onExpire","_ref$timeout","_ref$rejectOnExpire","resolve_","reject_","timeout_","timeoutDuration_","rejectOnExpire_","onExpire_","isFinished_","promise","expire","clearTimeout_","_len","args","Array","_key","apply","_len2","_key2","Math","random","pow","slice","clone","ServerRoom","connections","connectionId","keys","broadcast_","Connection","WebSocketServer","Server","INVALID_OPTIONS","INVALID_ACTION","port","bindEvents_","onConnection_","onHeaders_","headers","HEADERS","getConnections","broadcast","getRoom","CONNECTION"],"mappings":"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","file":"server.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 25);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nfunction LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = new Error().stack;\n}\nLineError.prototype = new Error();\n\nmodule.exports = LineError;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/assign\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar isUndefined = __webpack_require__(21);\nvar isString = __webpack_require__(20);\nvar isObject = __webpack_require__(7);\nvar isFunction = __webpack_require__(19);\nvar values = __webpack_require__(23);\nvar assign = __webpack_require__(1);\n\nvar _require = __webpack_require__(14),\n    generateDummyId = _require.generateDummyId;\n\nvar EventEmitterExtra = __webpack_require__(4);\nvar LineError = __webpack_require__(0);\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\n\nvar Message = function (_EventEmitterExtra) {\n    _inherits(Message, _EventEmitterExtra);\n\n    _createClass(Message, null, [{\n        key: 'parse',\n        value: function parse(raw) {\n            try {\n                var data = JSON.parse(raw);\n\n                // If error is error-like object, construct real error\n                if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                    data.e = assign(new Error(), data.e);\n                }\n\n                return new Message({\n                    name: data.n,\n                    payload: data.p,\n                    err: data.e,\n                    id: data.i\n                });\n            } catch (err) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Could not parse incoming message.');\n            }\n        }\n    }]);\n\n    function Message(_ref) {\n        var name = _ref.name,\n            payload = _ref.payload,\n            id = _ref.id,\n            err = _ref.err;\n\n        _classCallCheck(this, Message);\n\n        var _this = _possibleConstructorReturn(this, (Message.__proto__ || Object.getPrototypeOf(Message)).call(this));\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message payload or error must be json-friendly. Maybe circular json?');\n        }\n\n        _this.name = name;\n        _this.payload = payload;\n        _this.id = id;\n        _this.err = err;\n\n        _this.isResponded_ = false;\n        return _this;\n    }\n\n    _createClass(Message, [{\n        key: 'setId',\n        value: function setId() {\n            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generateDummyId();\n\n            this.id = id;\n            return id;\n        }\n    }, {\n        key: 'createResponse',\n        value: function createResponse(err, payload) {\n            return new Message({ name: '_r', payload: payload, err: err, id: this.id });\n        }\n\n        /**\n         * Resolves the message with sending a response back. If the source\n         * does not expecting a response, you don't need to call these methods.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} payload\n         */\n\n    }, {\n        key: 'resolve',\n        value: function resolve(payload) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be resolved (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(payload);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('resolved', payload);\n        }\n\n        /**\n         * Rejects the message, with sending error response back to the source.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} err\n         */\n\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be rejected (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(err);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('rejected', err);\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            var data = { n: this.name };\n\n            if (!isUndefined(this.payload)) data.p = this.payload;\n\n            if (!isUndefined(this.id)) data.i = this.id;\n\n            if (!isUndefined(this.err)) {\n                data.e = this.err instanceof Error ? assign({\n                    name: this.err.name,\n                    message: this.err.message\n                }, this.err) : this.err;\n            }\n\n            // We're sure the data is json-friendly\n            return JSON.stringify(data);\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            var _this2 = this;\n\n            var events = this.eventNames();\n            events.forEach(function (event) {\n                return _this2.removeAllListeners(event);\n            });\n        }\n    }]);\n\n    return Message;\n}(EventEmitterExtra);\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\n\n\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\nMessage.ReservedNames = values(Message.Name);\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded'\n};\n\nmodule.exports = Message;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"debug\");\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"event-emitter-extra\");\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/forEach\");\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isInteger\");\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isObject\");\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Message = __webpack_require__(2);\nvar EventEmitterExtra = __webpack_require__(4);\nvar assign = __webpack_require__(1);\nvar forEach = __webpack_require__(5);\nvar isInteger = __webpack_require__(6);\nvar isObject = __webpack_require__(7);\nvar debounce = __webpack_require__(17);\nvar Deferred = __webpack_require__(13);\nvar uuid = __webpack_require__(24);\nvar Debug = __webpack_require__(3);\nvar LineError = __webpack_require__(0);\nvar CloseStatus = __webpack_require__(12);\n\nvar debug = void 0;\n\n/**\n * Server connection class. Constructor of this class is not publicly accessible.\n * When you listen `Server.Event.CONNECTION` or `Server.Event.HANDSHAKE`, an instance\n * of `ServerConnection` will be emitted.\n *\n * @class ServerConnection\n * @extends {EventEmitterExtra}\n * @private\n * @property {string} id Unique connection id\n */\n\nvar ServerConnection = function (_EventEmitterExtra) {\n    _inherits(ServerConnection, _EventEmitterExtra);\n\n    function ServerConnection(socket, server) {\n        _classCallCheck(this, ServerConnection);\n\n        var _this = _possibleConstructorReturn(this, (ServerConnection.__proto__ || Object.getPrototypeOf(ServerConnection)).call(this));\n\n        _this.id = uuid.v4();\n        debug = Debug('line:server:connection:' + _this.id);\n        debug('Creating connection with id ' + _this.id + ' ...');\n\n        _this.socket = socket;\n        _this.server = server;\n        _this.state = ServerConnection.State.AWAITING_HANDSHAKE;\n\n        _this.deferreds_ = {};\n        _this.autoPing_ = debounce(function () {});\n\n        _this.socket.on('message', _this.onMessage_.bind(_this));\n        _this.socket.on('error', _this.onError_.bind(_this));\n        _this.socket.on('close', _this.onClose_.bind(_this));\n\n        _this.idleTimeout = new Deferred();\n        _this.idleTimeoutDuration = server.options.pingInterval * 100;\n\n        if (server.options.pingInterval > 0) {\n            /**\n             * Handle the weird rare state of connection where despite a successful closure residuals still remain in rooms.\n             */\n            _this.idleTimeout = new Deferred({ timeout: _this.idleTimeoutDuration, rejectOnExpire: false,\n                onExpire: function onExpire() {\n                    var persistsInRoot = !!_this.server.rooms.root.getConnectionById(_this.id);\n                    var belongingRooms = _this.getRooms().length;\n\n                    if (persistsInRoot || belongingRooms !== 0) {\n                        debug('Could not dispose this connection somehow. ' + ('ReadyState = ' + ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'][_this.socket.readyState] + ' | ') + ('Persists in root room: ' + persistsInRoot + ' | ') + ('Belongs to this many rooms: ' + belongingRooms));\n\n                        _this.server.rooms.removeFromAll(_this);\n                        _this.server.rooms.root.remove(_this);\n                        _this.state = ServerConnection.State.DISCONNECTED;\n                        _this.emit(ServerConnection.Event.DISCONNECTED, ServerConnection.ErrorCode.IDLE_TIMEOUT, 'Stayed idle for ' + _this.idleTimeoutDuration);\n                    }\n                }\n            });\n\n            _this.autoPing_ = debounce(function () {\n                _this.ping().then(function () {\n\n                    debug('Auto-ping successful');\n                    _this.idleTimeout.delay();\n\n                    if (server.options.pingInterval > 0 && _this.state == ServerConnection.State.CONNECTED) {\n                        _this.autoPing_();\n                    } else {\n                        debug('Canceling auto-ping, state: ' + _this.state);\n                    }\n                }).catch(function (err) {\n                    /* Disconnection is handled in ping */\n                    debug('Auto-ping failed, state: ' + _this.state, err);\n                });\n            }, server.options.pingInterval);\n        }\n\n        if (server.options.handshakeTimeout > 0) {\n            _this.handshakeTimeout_ = setTimeout(function () {\n                if (_this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n                    return debug('Handshake is not awaiting, ignoring handshake timeout...');\n                }\n\n                debug('Handshake timeout exceed, closing the connection...');\n                _this.close(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake not completed after ' + server.options.handshakeTimeout + ' ms');\n            }, server.options.handshakeTimeout);\n        }\n        return _this;\n    }\n\n    /**\n     * Native \"message\" event handler.\n     *\n     * @param {string|Buffer} data\n     * @param {Object} flags\n     * @param {boolean} flags.binary Specifies if data is binary.\n     * @param {boolean} flags.Boolean Specifies if data was masked.\n     * @ignore\n     */\n\n\n    _createClass(ServerConnection, [{\n        key: 'onMessage_',\n        value: function onMessage_(data, flags) {\n            debug('Native \"message\" event recieved: ' + data);\n            var message = void 0;\n\n            // A message is recieved, debounce our auto-ping handler if connected\n            if (this.state == ServerConnection.State.CONNECTED) {\n                this.autoPing_();\n            }\n\n            try {\n                message = Message.parse(data);\n            } catch (err) {\n                this.emit(ServerConnection.Event.ERROR, new LineError(ServerConnection.ErrorCode.INVALID_JSON, 'Could not parse message, invalid json. Check payload for incoming data.', data));\n                return;\n            }\n\n            this.idleTimeout.delay();\n\n            /**\n             * Route the incoming message\n             */\n            if (message.name == Message.Name.HANDSHAKE) {\n                // Handshake\n                this.onHandshakeMessage_(message);\n            } else if (message.name == Message.Name.PING) {\n                // Ping\n                this.onPingMessage_(message);\n            } else if (message.name == Message.Name.RESPONSE) {\n                // Message response\n                this.onResponseMessage_(message);\n            } else if (Message.ReservedNames.indexOf(message.name) == -1) {\n                // If message name is not reserved\n                if (!message.id) {\n                    // Message without response (no id fields)\n                    this.onMessageWithoutResponse_(message);\n                } else {\n                    // Message arrived awaiting its response\n                    this.onMessageWithResponse_(message);\n                }\n            } else {\n                debug('Could not route the message', message);\n            }\n        }\n\n        /**\n         * On \"handshake\" message handler.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onHandshakeMessage_',\n        value: function onHandshakeMessage_(message) {\n            var _this2 = this;\n\n            if (this.state == ServerConnection.State.CONNECTED) {\n                debug('Handshake message recieved but, handshake is already resolved, ignoring...');\n                return this.sendWithoutResponse_(message.createResponse(new Error('Handshake is already resolved'))).catch(function () {/* Ignoring */});\n            }\n\n            debug('Handshake message recieved: ' + message);\n\n            /**\n             * If handshake is resolved\n             */\n            message.once('resolved', function (payload) {\n                debug('Handshake is resolved, sending response...');\n                _this2.state = ServerConnection.State.CONNECTED;\n                _this2.handshakeTimeout_ && clearTimeout(_this2.handshakeTimeout_);\n                _this2.autoPing_(); // Start auto-pinging\n\n                var responsePayload = {\n                    payload: payload,\n                    id: _this2.id\n                };\n\n                _this2.sendWithoutResponse_(message.createResponse(null, responsePayload)).then(function () {\n                    debug('Handshake resolving response is sent, emitting connection...');\n                    _this2.server.rooms.root.add(_this2);\n                    _this2.server.emit('connection', _this2);\n                }).catch(function (err) {\n                    debug('Could not send handshake response', err);\n\n                    // TODO: Emit these errors from the server\n                    if (err instanceof LineError) {\n                        switch (err.code) {\n                            case ServerConnection.ErrorCode.DISCONNECTED:\n                                debug('Connection is gone before handshake completed, ignoring...');\n                                return;\n\n                            case ServerConnection.ErrorCode.WEBSOCKET_ERROR:\n                                // TODO: Try again!\n                                debug('Native websocket error', err.payload);\n                                return _this2.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n\n                            default:\n                                debug('Unhandled line error', err);\n                                return _this2.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                        }\n                    }\n\n                    debug('Unknown error', err);\n                    return _this2.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                }).then(function () {\n                    message.dispose();\n                });\n            });\n\n            /**\n             * Id handshake is rejected\n             */\n            message.once('rejected', function (err) {\n                debug('Handshake is rejected, sending response...');\n\n                _this2.sendWithoutResponse_(message.createResponse(err)).catch(function (err) {\n                    return debug('Handshake rejecting response could not sent, manually calling \"close\"...', err);\n                }).then(function () {\n                    return _this2.close(CloseStatus.HANDSHAKE_REJECTED.code, CloseStatus.HANDSHAKE_REJECTED.reason, 50);\n                }).then(function () {\n                    message.dispose();\n                });\n            });\n\n            /**\n             * Emit handshake event from the server\n             */\n            debug('Emitting server\\'s \"handshake\" event...');\n            var handshakeListener = this.server.emit('handshake', this, message);\n\n            if (!handshakeListener) {\n                debug('There is no handshake listener, resolving the handshake by default...');\n                message.resolve();\n            }\n        }\n\n        /**\n         * On \"ping\" message handler. Reply with pong.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onPingMessage_',\n        value: function onPingMessage_(message) {\n            debug('Ping received, responding with \"pong\"...');\n\n            this.sendWithoutResponse_(message.createResponse(null, 'pong')).catch(function (err) {\n                return debug('Ping response failed to send back, ignoring for now...', err);\n            });\n        }\n\n        /**\n         * A message is recieved, and its response is expected.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onResponseMessage_',\n        value: function onResponseMessage_(message) {\n            var deferred = this.deferreds_[message.id];\n            if (!deferred) return;\n\n            if (message.err) {\n                debug('Response (rejecting) recieved: ' + message);\n                var err = new LineError(ServerConnection.ErrorCode.MESSAGE_REJECTED, 'Message is rejected by server, check payload.', message.err);\n                deferred.reject(err);\n            } else {\n                debug('Response (resolving) recieved: ' + message);\n                deferred.resolve(message.payload);\n            }\n\n            delete this.deferreds_[message.id];\n        }\n\n        /**\n         * A message is arrived without waiting its response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithoutResponse_',\n        value: function onMessageWithoutResponse_(message) {\n            debug('Message without response: name=\"' + message.name + '\"');\n            this.emit(message.name, message);\n        }\n\n        /**\n         * A message is arrived and the client is expecting its response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithResponse_',\n        value: function onMessageWithResponse_(message) {\n            var _this3 = this;\n\n            debug('Message with response: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n            message.once('resolved', function (payload) {\n                debug('Message #' + message.id + ' is resolved, sending response...');\n                _this3.sendWithoutResponse_(message.createResponse(null, payload)).catch(function (err) {\n                    _this3.emit(ServerConnection.Event.ERROR, new LineError(ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (resolve)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            message.once('rejected', function (err) {\n                debug('Message #' + message.id + ' is rejected, sending response...');\n                _this3.sendWithoutResponse_(message.createResponse(err)).catch(function (err) {\n                    _this3.emit(ServerConnection.Event.ERROR, new LineError(ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (reject)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            this.emit(message.name, message);\n        }\n\n        /**\n         * Native \"error\" event.\n         *\n         * @param {Error} err\n         * @ignore\n         */\n\n    }, {\n        key: 'onError_',\n        value: function onError_(err) {\n            debug('Native \"error\" event recieved, emitting line\\'s \"error\" event: ' + err);\n            this.emit(ServerConnection.Event.ERROR, err);\n        }\n\n        /**\n         * Native \"close\" event.\n         *\n         * @param {number} code\n         * @param {string=} reason\n         * @ignore\n         */\n\n    }, {\n        key: 'onClose_',\n        value: function onClose_(code, reason) {\n            debug('Native \"close\" event recieved with code ' + code + ': ' + reason);\n            debug('Removing connection from all rooms, rejecting all waiting messages...');\n\n            this.handshakeTimeout_ && clearTimeout(this.handshakeTimeout_);\n            this.autoPing_.cancel();\n            this.server.rooms.removeFromAll(this);\n            this.server.rooms.root.remove(this);\n            this.rejectAllDeferreds_(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Socket connection closed!'));\n\n            debug('Emitting line\\'s \"close\" event...');\n            this.state = ServerConnection.State.DISCONNECTED;\n            this.emit(ServerConnection.Event.DISCONNECTED, code, reason);\n        }\n\n        /**\n         * Changes connection's id, it's random by default. This method is helpful if you already have\n         * custom identification for your clients. You must do this before handshake resolved. If\n         * handshake is already resolved or there is conflict, this method will throw error.\n         *\n         * Throws:\n         * - `ServerConnection.ErrorCode.HANDSHAKE_ENDED`: Id could not be changed after handshake\n         * - `ServerConnection.ErrorCode.ID_CONFLICT`: There is alrady another connection with provided id.\n         *\n         * @param {string} newId New connection id\n         * @memberOf ServerConnection\n         * @example\n         * server.on(Server.Event.HANDSHAKE, (connection, handshake) => {\n         *   // Assuming client's `options.handshake.payload` is something like `{authToken: '...'}`\n         *\n         *   // Imaginary db\n         *   db.find(handshake.payload.authToken, (record) => {\n         *     if (!record) return handshake.reject(new Error('Invalid auth token'));\n         *     connection.setId(record.id);\n         *     handshake.resolve(record);\n         *   });\n         * });\n         */\n\n    }, {\n        key: 'setId',\n        value: function setId(newId) {\n            if (this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n                throw new LineError(ServerConnection.ErrorCode.HANDSHAKE_ENDED, 'Handshake already ended, you cannot change connection id anymore');\n            }\n\n            if (this.server.getConnectionById(newId)) {\n                throw new LineError(ServerConnection.ErrorCode.ID_CONFLICT, 'Conflict! There is already connection with id ' + newId);\n            }\n\n            this.id = newId;\n            debug = Debug('line:server:connection:' + this.id);\n        }\n\n        /**\n         * Joins the connection into provided room. If there is no room, it will be created automatically.\n         *\n         * @param {string} roomName\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'joinRoom',\n        value: function joinRoom(roomName) {\n            this.server.rooms.add(roomName, this);\n        }\n\n        /**\n         * Leaves the connection from provided room.\n         *\n         * @param {string} roomName\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'leaveRoom',\n        value: function leaveRoom(roomName) {\n            this.server.rooms.remove(roomName, this);\n        }\n\n        /**\n         * Gets the joined room names.\n         *\n         * @returns {Array<string>}\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'getRooms',\n        value: function getRooms() {\n            return this.server.rooms.getRoomsOf(this);\n        }\n\n        /**\n         * Sends a message to client with awaiting its response. This method returns a promise\n         * which resolves the payload parameter will be passed into `message.resolve(...)` in client-side.\n         *\n         * If client rejects the message with `message.reject(...)`, this promise will be rejected with\n         * `ServerConnection.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n         * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {string} name\n         * @param {any=} payload\n         * @param {number=} timout\n         * @returns {Promise<any>}\n         * @memberOf ServerConnection\n         * @example\n         * connection\n         *   .send('hello', {optional: 'payload'})\n         *   .then((data) => {\n         *     // Message is resolved by client\n         *   })\n         *   .catch((err) => {\n         *     // Could not send message\n         *     // or\n         *     // Client rejected the message!\n         *   });\n         */\n\n    }, {\n        key: 'send',\n        value: function send(name, payload, opt_timeout) {\n            // This method is for external usage!\n            if (this.state != ServerConnection.State.CONNECTED) {\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload });\n                return this.send_(message, opt_timeout);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Sends a message to client without waiting its response. This method returns a promise\n         * that resolves with nothing if the message is successfully sent.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {string} name\n         * @param {any=} payload\n         * @returns {Promise}\n         * @memberOf ServerConnection\n         * @example\n         * connection\n         *   .sendWithoutResponse('hello', {optional: 'payload'})\n         *   .then(() => {\n         *     // Message sent successfully\n         *   })\n         *   .catch((err) => {\n         *     // Message could not be sent to client\n         *   })\n         */\n\n    }, {\n        key: 'sendWithoutResponse',\n        value: function sendWithoutResponse(name, payload) {\n            // For external usage\n            if (this.state != ServerConnection.State.CONNECTED) {\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload }); // Can throw Message.ErrorCode.INVALID_JSON\n                return this.sendWithoutResponse_(message);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Base method for sending a message with timeout. Please favor this method internally\n         * instead of using `send` method.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n         * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {Message} message\n         * @param {number=} opt_timeout\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'send_',\n        value: function send_(message, opt_timeout) {\n            var _this4 = this;\n\n            var timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.server.options.responseTimeout;\n            message.setId();\n\n            var deferred = this.deferreds_[message.id] = new Deferred({\n                onExpire: function onExpire() {\n                    delete _this4.deferreds_[message.id];\n                },\n                timeout: timeout\n            });\n\n            return this.sendWithoutResponse_(message).then(function () {\n                return deferred;\n            }).catch(function (err) {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(ServerConnection.ErrorCode.MESSAGE_TIMEOUT, 'Message timeout! Its response did not recived after ' + timeout + ' ms');\n                }\n\n                throw err;\n            });\n        }\n\n        /**\n         * Base method for sending a message without response. Please favor this method internally\n         * instead of using `sendWithoutResponse` method.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {Message} message\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'sendWithoutResponse_',\n        value: function sendWithoutResponse_(message) {\n            var _this5 = this;\n\n            if (!this.socket || this.socket.readyState != 1) {\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Could not send message, there is no open connection.'));\n            }\n\n            return new Promise(function (resolve, reject) {\n                debug('Sending message: ' + message);\n                var messageStr = message.toString();\n\n                _this5.socket.send(messageStr, function (err) {\n                    if (err) {\n                        return reject(new LineError(ServerConnection.ErrorCode.WEBSOCKET_ERROR, 'Could not send message, native websocket error, check payload.', err));\n                    }\n\n                    resolve();\n                });\n            });\n        }\n\n        /**\n         * Pings the client. If there is no respose, closes the connection.\n         *\n         * @returns {Promise}\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'ping',\n        value: function ping() {\n            var _this6 = this;\n\n            debug('Pinging...');\n            return this.send_(new Message({ name: Message.Name.PING })).catch(function (err) {\n                // No matter what error is, start disconnection process\n                debug('Auto-ping failed, manually disconnecting...', err);\n                _this6.close(CloseStatus.PING_FAILED.code, CloseStatus.PING_FAILED.reason);\n                throw new LineError(ServerConnection.ErrorCode.PING_ERROR, 'Ping failed, manually disconnecting...', err);\n            });\n        }\n\n        /**\n         * Gracefully closes the client connection.\n         *\n         * @param {number=} code\n         * @param {string=} reason\n         * @param {number=} delay\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'close',\n        value: function close(code, reason, delay) {\n            var _this7 = this;\n\n            debug('Closing the connection in ' + (delay || 0) + ' ms with code: ' + code + '.');\n            return new Promise(function (resolve) {\n                setTimeout(function () {\n                    _this7.socket.close(code || 1000, reason);\n                }, delay || 0);\n            });\n        }\n\n        /**\n         * Reject all the awaiting deferred with given error.\n         *\n         * @param {Error} err An error object to reject all awaiting deferreds.\n         * @ignore\n         */\n\n    }, {\n        key: 'rejectAllDeferreds_',\n        value: function rejectAllDeferreds_(err) {\n            forEach(this.deferreds_, function (deferred) {\n                return deferred.reject(err);\n            });\n            this.deferreds_ = {};\n        }\n    }]);\n\n    return ServerConnection;\n}(EventEmitterExtra);\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\n\n\nServerConnection.ErrorCode = {\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method.\n     */\n    MESSAGE_TIMEOUT: 'scMessageTimeout',\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method,\n     * which again indicates that server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'scMessageRejected',\n    /**\n     * When the response of a message failed to send to client, this error\n     * will be emitted in `ServerConnection.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'scInvalidJson',\n    /**\n     * This error can be thrown in `serverConnection.setId()`. Connection id\n     * cannot be set after handshake.\n     */\n    HANDSHAKE_ENDED: 'scHandshakeEnded',\n    /**\n     * This error can be seen while using `serverConnection.setId()`. If there is\n     * already connection with that id, this error will be thrown.\n     */\n    ID_CONFLICT: 'scIdConflict',\n    /**\n     * This error indicates client is disconnected.\n     */\n    DISCONNECTED: 'scDisconnected',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'scWebsocketError',\n    /**\n     * This error can be seen in rejection of `serverConnection.ping()` method.\n     */\n    PING_ERROR: 'scPingError',\n    /**\n     * This error is thrown when a connection won't ping-pong for too long.\n     */\n    IDLE_TIMEOUT: 'scIdleTimeout'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.State = {\n    /**\n     * `awaitingHandshake` Connection is open but handshake is not completed yet.\n     */\n    AWAITING_HANDSHAKE: 'awaitingHandshake',\n    /**\n     * `connected` Connection is open and handshake resolved.\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnected` There is no open connection.\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.Event = {\n    /**\n     * `_error`\n     */\n    ERROR: '_error',\n    /**\n     * `_close`\n     */\n    DISCONNECTED: '_disconnected'\n};\n\nmodule.exports = ServerConnection;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar filter = __webpack_require__(18);\nvar forEach = __webpack_require__(5);\nvar map = __webpack_require__(22);\nvar Room = __webpack_require__(15);\n\nvar Rooms = function () {\n    function Rooms() {\n        _classCallCheck(this, Rooms);\n\n        this.rooms = {};\n        this.root = new Room();\n    }\n\n    _createClass(Rooms, [{\n        key: 'add',\n        value: function add(roomName, connection) {\n            if (!this.rooms[roomName]) this.rooms[roomName] = new Room(roomName);\n\n            this.rooms[roomName].add(connection);\n        }\n    }, {\n        key: 'remove',\n        value: function remove(roomName, connection) {\n            if (!this.rooms[roomName]) return;\n\n            this.rooms[roomName].remove(connection);\n\n            if (!this.rooms[roomName].getConnectionsCount()) delete this.rooms[roomName];\n        }\n    }, {\n        key: 'getRoomsOf',\n        value: function getRoomsOf(connection) {\n            return map(filter(this.rooms, function (room) {\n                return room.getConnectionById(connection.id);\n            }), 'name');\n        }\n    }, {\n        key: 'getRoom',\n        value: function getRoom(room) {\n            return this.rooms[room];\n        }\n    }, {\n        key: 'removeFromAll',\n        value: function removeFromAll(connection) {\n            var _this = this;\n\n            var rooms = this.getRoomsOf(connection);\n            forEach(rooms, function (roomName) {\n                return _this.rooms[roomName].remove(connection);\n            });\n        }\n    }]);\n\n    return Rooms;\n}();\n\nmodule.exports = Rooms;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"uws\");\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"ws\");\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nmodule.exports = {\n    INTERNAL_ERROR: { code: 4200, reason: 'Internal error' },\n    PING_FAILED: { code: 4201, reason: 'Ping failed' },\n    HANDSHAKE_FAILED: { code: 4202, reason: 'Handshake failed' },\n    HANDSHAKE_REJECTED: { code: 4203, reason: 'Handshake rejected' },\n    DISCONNECT_TIMEOUT: { code: 4204, reason: 'Disconnect timeout' },\n    DISPOSED: { code: 4205, reason: 'Client disposed' },\n    UNKNOWN_ERROR: { code: 4299, reason: 'Unknown error' }\n};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LineError = __webpack_require__(0);\n\nvar Deferred = function () {\n    function Deferred() {\n        var _this = this;\n\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref$handler = _ref.handler,\n            handler = _ref$handler === undefined ? function () {} : _ref$handler,\n            _ref$onExpire = _ref.onExpire,\n            onExpire = _ref$onExpire === undefined ? function () {} : _ref$onExpire,\n            _ref$timeout = _ref.timeout,\n            timeout = _ref$timeout === undefined ? 0 : _ref$timeout,\n            _ref$rejectOnExpire = _ref.rejectOnExpire,\n            rejectOnExpire = _ref$rejectOnExpire === undefined ? true : _ref$rejectOnExpire;\n\n        _classCallCheck(this, Deferred);\n\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.rejectOnExpire_ = rejectOnExpire;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve_ = resolve;\n            _this.reject_ = reject;\n\n            try {\n                handler(_this);\n            } catch (err) {\n                _this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n    _createClass(Deferred, [{\n        key: 'resolve',\n        value: function resolve(data) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.resolve_(data);\n        }\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.reject_(err);\n        }\n    }, {\n        key: 'expire',\n        value: function expire() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.onExpire_();\n\n            if (this.rejectOnExpire_) this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, 'Timeout ' + this.timeoutDuration_ + ' ms exceed'));\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n        }\n    }, {\n        key: 'delay',\n        value: function delay(timeout) {\n            if (this.timeoutDuration_ > 0) {\n                this.clearTimeout_();\n                this.timeout_ = setTimeout(this.expire.bind(this), timeout || this.timeoutDuration_);\n            }\n        }\n    }, {\n        key: 'then',\n        value: function then() {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            return this.promise.then.apply(this.promise, args);\n        }\n    }, {\n        key: 'catch',\n        value: function _catch() {\n            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n            }\n\n            return this.promise.catch.apply(this.promise, args);\n        }\n    }, {\n        key: 'clearTimeout_',\n        value: function clearTimeout_() {\n            if (this.timeout_) {\n                clearTimeout(this.timeout_);\n                this.timeout_ = null;\n            }\n        }\n    }]);\n\n    return Deferred;\n}();\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\nmodule.exports = Deferred;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\n\nvar assign = __webpack_require__(1);\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId() {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n\n    return (\"0000\" + (Math.random() * Math.pow(36, length) << 0).toString(36)).slice(-length);\n}\n\nmodule.exports = { generateDummyId: generateDummyId };\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar forEach = __webpack_require__(5);\nvar clone = __webpack_require__(16);\nvar Message = __webpack_require__(2);\nvar debug = __webpack_require__(3)('line:server:room');\nvar LineError = __webpack_require__(0);\n\n/**\n * Line room class.\n *\n * @private\n * @class ServerRoom\n * @param {string} name Room name\n * @property {string} name\n */\n\nvar ServerRoom = function () {\n    function ServerRoom(name) {\n        var connections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, ServerRoom);\n\n        this.name = name;\n        this.connections = connections;\n    }\n\n    /**\n     * Adds a connection into room.\n     * @param {ServerConnection} connection\n     */\n\n\n    _createClass(ServerRoom, [{\n        key: 'add',\n        value: function add(connection) {\n            // TODO: Check current existing connection maybe?\n            this.connections[connection.id] = connection;\n        }\n\n        /**\n         * Removes a connection from room.\n         * @param {ServerConnection} connection\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'remove',\n        value: function remove(connection) {\n            if (connection != this.connections[connection.id]) {\n                debug('[' + (this.name || 'root') + '] Did not remove \"' + connection.id + '\", connection instance is not added or different');\n                return false;\n            }\n\n            debug('[' + (this.name || 'root') + '] Removing \"' + connection.id + '\"');\n            delete this.connections[connection.id];\n            return true;\n        }\n\n        /**\n         * Gets a connection by id.\n         * @param {string} connectionId\n         * @returns {?ServerConnection}\n         */\n\n    }, {\n        key: 'getConnectionById',\n        value: function getConnectionById(connectionId) {\n            return this.connections[connectionId];\n        }\n\n        /**\n         * Gets all connections in the room. Returns a object where keys are\n         * connection id and values are ServerConnection.\n         * @returns {{string: ServerConnection}}\n         */\n\n    }, {\n        key: 'getConnections',\n        value: function getConnections() {\n            return clone(this.connections);\n        }\n\n        /**\n         * Returns the total connection count in room.\n         * @returns {number}\n         */\n\n    }, {\n        key: 'getConnectionsCount',\n        value: function getConnectionsCount() {\n            return Object.keys(this.connections).length;\n        }\n    }, {\n        key: 'broadcast_',\n        value: function broadcast_(message) {\n            var _this = this;\n\n            forEach(this.connections, function (connection) {\n                connection.sendWithoutResponse_(message).catch(function (err) {\n                    debug('[' + (_this.name || 'root') + '] Could not send \"' + message.name + '\" to \"' + connection.id + '\" while broadcasting, ignoring...');\n                });\n            });\n        }\n\n        /**\n         * Broadcast a message to all connections in the room.\n         * @param {string} name\n         * @param {any=} payload\n         */\n\n    }, {\n        key: 'broadcast',\n        value: function broadcast(name, payload) {\n            var message = new Message({ name: name, payload: payload }); // Can throw INVALID_JSON\n            this.broadcast_(message);\n        }\n    }]);\n\n    return ServerRoom;\n}();\n\nmodule.exports = ServerRoom;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/clone\");\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/debounce\");\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/filter\");\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isFunction\");\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isString\");\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isUndefined\");\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/map\");\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/values\");\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"uuid\");\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Connection = __webpack_require__(8);\nvar Message = __webpack_require__(2);\nvar Rooms = __webpack_require__(9);\nvar EventEmitterExtra = __webpack_require__(4);\nvar debug = __webpack_require__(3)('line:server');\nvar LineError = __webpack_require__(0);\nvar assign = __webpack_require__(1);\nvar isInteger = __webpack_require__(6);\n\nvar WebSocketServer = void 0;\ntry {\n    WebSocketServer = __webpack_require__(10).Server;\n} catch (err) {\n    WebSocketServer = __webpack_require__(11).Server;\n    debug('Could not find module uws, falling back to ws', err);\n}\n\n/**\n * Line Server Class\n *\n * @class Server\n * @extends {EventEmitterExtra}\n * @param {Object=} options Options object.\n * @param {string=} options.host The hostname where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.port The port where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {http.Server=} options.server A pre-created Node.js HTTP server. If provided, `host` and `port`\n *      will ignored. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {string=} options.path Accept only connections matching this path. [Inherited from uws](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.responseTimeout Default timeout duration (in ms) for message responses. Default: `10000` (10 seconds)\n * @param {number=} options.handshakeTimeout This is the duration how long a client can stay connected\n *      without handshake. Default `60000` (1 minute).\n * @param {number=} options.pingInterval Ping interval in ms. Default: 15 seconds.\n * @example\n * const Server = require('line-socket/server');\n * const server = new Server({\n *   port: 8080\n * });\n */\n\nvar Server = function (_EventEmitterExtra) {\n    _inherits(Server, _EventEmitterExtra);\n\n    function Server() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Server);\n\n        var _this = _possibleConstructorReturn(this, (Server.__proto__ || Object.getPrototypeOf(Server)).call(this));\n\n        _this.options = assign({\n            responseTimeout: 10000,\n            handshakeTimeout: 60000,\n            pingInterval: 15000\n        }, options);\n\n        if (!isInteger(_this.options.responseTimeout) || _this.options.responseTimeout < 0) throw new LineError(Server.ErrorCode.INVALID_OPTIONS, '\"options.responseTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.handshakeTimeout) || _this.options.handshakeTimeout < 0) throw new LineError(Server.ErrorCode.INVALID_OPTIONS, '\"options.handshakeTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.pingInterval) || _this.options.pingInterval < 0) throw new LineError(Server.ErrorCode.INVALID_OPTIONS, '\"options.pingInterval\" must be a positive integer or zero');\n\n        _this.rooms = new Rooms();\n\n        debug('Initalizing with options: ' + JSON.stringify(_this.options));\n        return _this;\n    }\n\n    /**\n     * Starts the server.\n     *\n     * @returns {Promise}\n     * @memberOf Server\n     * @example\n     * server\n     *   .start()\n     *   .then(() => {\n     *     console.log('Server started');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Server could not started', err);\n     *   });\n     */\n\n\n    _createClass(Server, [{\n        key: 'start',\n        value: function start() {\n            var _this2 = this;\n\n            if (this.server) {\n                return Promise.reject(new LineError(Server.ErrorCode.INVALID_ACTION, 'Could not start server, already started!'));\n            }\n\n            if (!this.options.port) {\n                debug('Starting without port...');\n\n                try {\n                    this.server = new WebSocketServer(this.options);\n                    this.bindEvents_();\n                    return Promise.resolve();\n                } catch (err) {\n                    return Promise.reject(new LineError(Server.ErrorCode.WEBSOCKET_ERROR, 'Could not start the server, websocket error, check payload', err));\n                }\n            }\n\n            return new Promise(function (resolve, reject) {\n                debug('Starting with port \"' + _this2.options.port + '\" ...');\n\n                _this2.server = new WebSocketServer(_this2.options, function (err) {\n                    if (err) {\n                        debug('Could not start: ' + err);\n                        return reject(new LineError(Server.ErrorCode.WEBSOCKET_ERROR, 'Could not start the server, websocket error, check payload', err));\n                    }\n\n                    _this2.bindEvents_();\n                    resolve();\n                });\n            });\n        }\n\n        /**\n         * Stops the server.\n         *\n         * @returns {Promise}\n         * @memberOf Server\n         * @example\n         * server\n         *   .stop()\n         *   .then(() => {\n         *     console.log('Server stopped');\n         *   })\n         *   .catch((err) => {\n         *     console.log('Server could not stopped', err);\n         *   });\n         */\n\n    }, {\n        key: 'stop',\n        value: function stop() {\n            var _this3 = this;\n\n            if (!this.server) {\n                debug('Could not stop server. Server is probably not started, or already stopped.');\n                return Promise.reject(new LineError(Server.ErrorCode.INVALID_ACTION, 'Could not stop server. Server is probably not started, or already stopped!'));\n            }\n\n            return new Promise(function (resolve) {\n                debug('Closing and disposing the server...');\n                _this3.server.close();\n                _this3.server = null;\n                resolve();\n            });\n        }\n\n        /**\n         * Binds websocket server events.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'bindEvents_',\n        value: function bindEvents_() {\n            debug('Binding server events...');\n\n            this.server.on('connection', this.onConnection_.bind(this));\n            this.server.on('headers', this.onHeaders_.bind(this));\n            this.server.on('error', this.onError_.bind(this));\n        }\n\n        /**\n         * Native \"connection\" event handler.\n         *\n         * @param {WebSocket} socket\n         * @ignore\n         */\n\n    }, {\n        key: 'onConnection_',\n        value: function onConnection_(socket) {\n            debug('Native \"connection\" event recieved, creating line connection...');\n            var connection = new Connection(socket, this);\n        }\n\n        /**\n         * Native \"headers\" event handler.\n         *\n         * @param {Array} headers\n         * @ignore\n         */\n\n    }, {\n        key: 'onHeaders_',\n        value: function onHeaders_(headers) {\n            debug('Native \"headers\" event recieved, emitting line\\'s \"headers\" event... (' + headers + ')');\n            this.emit(Server.Event.HEADERS, headers);\n        }\n\n        /**\n         * Native \"error\" event handler.\n         *\n         * @param {Error} err\n         * @ignore\n         */\n\n    }, {\n        key: 'onError_',\n        value: function onError_(err) {\n            debug('Native \"error\" event recieved, emitting line\\'s \"error\" event... (' + err + ')');\n            this.emit(Server.Event.ERROR, err);\n        }\n\n        /**\n         * Returns a object where keys are connection id and values are ServerConnection.\n         *\n         * @returns {{string: ServerConnection}}\n         * @memberOf Server\n         */\n\n    }, {\n        key: 'getConnections',\n        value: function getConnections() {\n            return this.rooms.root.getConnections();\n        }\n\n        /**\n         * Gets a connection by id\n         *\n         * @param {string} id Unique connection id, which can be accessed at `connection.id`\n         * @returns {?ServerConnection}\n         * @memberOf Server\n         * @example\n         * const connection = server.getConnectionById('someId');\n         *\n         * if (connection) {\n         *   connection.send('hello', {optional: 'payload'});\n         * }\n         */\n\n    }, {\n        key: 'getConnectionById',\n        value: function getConnectionById(id) {\n            return this.rooms.root.getConnectionById(id);\n        }\n\n        /**\n         * Broadcasts a message to all the connected (& handshaked) clients.\n         *\n         * @param {string} name Message name\n         * @param {any=} payload Optional message payload.\n         * @memberOf Server\n         * @example\n         * server.broadcast('hello', {optional: 'payload'});\n         */\n\n    }, {\n        key: 'broadcast',\n        value: function broadcast(name, payload) {\n            debug('Broadcasting \"' + name + '\" message...');\n            this.rooms.root.broadcast(name, payload); // Can throw INVALID_JSON\n        }\n\n        /**\n         * Gets a room by name.\n         * @param {string} room Room name\n         * @returns {?ServerRoom}\n         */\n\n    }, {\n        key: 'getRoom',\n        value: function getRoom(room) {\n            return this.rooms.getRoom(room);\n        }\n\n        /**\n         * Gets all the rooms of a connection.\n         * @param {ServerConnection} connection\n         * @returns {Array.<string>} Array of room names.\n         */\n\n    }, {\n        key: 'getRoomsOf',\n        value: function getRoomsOf(connection) {\n            return this.rooms.getRoomsOf(connection);\n        }\n\n        /**\n         * Remove a connection from all the rooms.\n         * @param {ServerConnection} connection\n         */\n\n    }, {\n        key: 'removeFromAllRooms',\n        value: function removeFromAllRooms(connection) {\n            this.rooms.removeFromAll(connection);\n        }\n    }]);\n\n    return Server;\n}(EventEmitterExtra);\n\n// Expose internal classes\n\n\nServer.Message = Message;\nServer.Connection = Connection;\nServer.Error = LineError;\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServer.ErrorCode = {\n    /**\n     * When constructing `new Server()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'sInvalidOptions',\n    /**\n     * This error can be seen in rejection of `server.start()` or `server.stop()` methods.\n     */\n    INVALID_ACTION: 'sInvalidAction',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'sWebsocketError'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n * @example\n * server.on('connection', (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // or better, you can use enums\n *\n * server.on(Server.Event.CONNECTION, (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // If you want to authorize your client\n * server.on('handshake', (connection, handshake) => {\n *   if (handshake.payload && handshake.payload.authToken == '...')\n *     handshake.resolve({welcome: 'bro'});\n *   else\n *     handshake.reject(new Error('Invalid auth token'));\n * });\n */\nServer.Event = {\n    /**\n     * `handshake` When a client connection is established, this event will be fired before\n     * `connection` event. Please note that, this event has nothing in common with native websocket\n     * handshaking process. If you want to authorize your clients, you must listen this event and\n     * call `handshake.resolve(...)` or `handshake.reject(...)` accordingly. If you do not consume\n     * this events, all the client connections will be accepted.\n     *\n     * ```\n     * function (connection, handshake) {}\n     * ```\n     *\n     * where `connection` is `ServerConnection` and `handshake` is a `Message` instance.\n     */\n    HANDSHAKE: 'handshake',\n    /**\n     * `connection` This event will fire on a client connects **after successful handshake**.\n     *\n     * ```\n     * function (connection) {}\n     * ```\n     *\n     * where `connection` is a `ServerConnection` instance.\n     */\n    CONNECTION: 'connection',\n    /**\n     * `'headers'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-headers)\n     */\n    HEADERS: 'headers',\n    /**\n     * `'error'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-error)\n     */\n    ERROR: 'error'\n};\n\nmodule.exports = Server;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// server.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 25);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f1e4d16c0b29e70e349b","function LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = (new Error()).stack;\n}\nLineError.prototype = new Error;\n\n\nmodule.exports = LineError;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/error.js","module.exports = require(\"lodash/assign\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/assign\"\n// module id = 1\n// module chunks = 0","const isUndefined = require('lodash/isUndefined');\nconst isString = require('lodash/isString');\nconst isObject = require('lodash/isObject');\nconst isFunction = require('lodash/isFunction');\nconst values = require('lodash/values');\nconst assign = require('lodash/assign');\nconst {generateDummyId} = require('./utils');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst LineError = require('./error');\n\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\nclass Message extends EventEmitterExtra {\n    static parse(raw) {\n        try {\n            const data = JSON.parse(raw);\n\n            // If error is error-like object, construct real error\n            if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                data.e = assign(new Error(), data.e);\n            }\n\n            return new Message({\n                name: data.n,\n                payload: data.p,\n                err: data.e,\n                id: data.i\n            });\n        } catch(err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, `Could not parse incoming message.`);\n        }\n    }\n\n\n    constructor({name, payload, id, err}) {\n        super();\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message payload or error must be json-friendly. Maybe circular json?`\n            );\n        }\n\n        this.name = name;\n        this.payload = payload;\n        this.id = id;\n        this.err = err;\n\n        this.isResponded_ = false;\n    }\n\n\n    setId(id = generateDummyId()) {\n        this.id = id;\n        return id;\n    }\n\n\n    createResponse(err, payload) {\n        return new Message({name: '_r', payload, err, id: this.id});\n    }\n\n\n    /**\n     * Resolves the message with sending a response back. If the source\n     * does not expecting a response, you don't need to call these methods.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} payload\n     */\n    resolve(payload) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be resolved (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n        try {\n            JSON.stringify(payload);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('resolved', payload);\n    }\n\n\n    /**\n     * Rejects the message, with sending error response back to the source.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} err\n     */\n    reject(err) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be rejected (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n\n        try {\n            JSON.stringify(err);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('rejected', err);\n    }\n\n\n    toString() {\n        const data = {n: this.name};\n\n        if (!isUndefined(this.payload))\n            data.p = this.payload;\n\n        if (!isUndefined(this.id))\n            data.i = this.id;\n\n        if (!isUndefined(this.err)) {\n            data.e = this.err instanceof Error ? assign({\n                name: this.err.name,\n                message: this.err.message\n            }, this.err) : this.err;\n        }\n\n        // We're sure the data is json-friendly\n        return JSON.stringify(data);\n    }\n\n\n    dispose() {\n        const events = this.eventNames();\n        events.forEach(event => this.removeAllListeners(event));\n    }\n}\n\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\n\nMessage.ReservedNames = values(Message.Name);\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded',\n};\n\n\nmodule.exports = Message;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/message.js","module.exports = require(\"debug\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"debug\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"event-emitter-extra\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"event-emitter-extra\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"lodash/forEach\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/forEach\"\n// module id = 5\n// module chunks = 0","module.exports = require(\"lodash/isInteger\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isInteger\"\n// module id = 6\n// module chunks = 0","module.exports = require(\"lodash/isObject\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isObject\"\n// module id = 7\n// module chunks = 0","const Message = require('../lib/message');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst assign = require('lodash/assign');\nconst forEach = require('lodash/forEach');\nconst isInteger = require('lodash/isInteger');\nconst isObject = require('lodash/isObject');\nconst debounce = require('lodash/debounce');\nconst Deferred = require('../lib/deferred');\nconst uuid = require('uuid');\nconst Debug = require('debug');\nconst LineError = require('../lib/error');\nconst CloseStatus = require('../lib/closestatus');\n\nlet debug;\n\n/**\n * Server connection class. Constructor of this class is not publicly accessible.\n * When you listen `Server.Event.CONNECTION` or `Server.Event.HANDSHAKE`, an instance\n * of `ServerConnection` will be emitted.\n *\n * @class ServerConnection\n * @extends {EventEmitterExtra}\n * @private\n * @property {string} id Unique connection id\n */\nclass ServerConnection extends EventEmitterExtra {\n    constructor(socket, server) {\n        super();\n\n        this.id = uuid.v4();\n        debug = Debug(`line:server:connection:${this.id}`);\n        debug(`Creating connection with id ${this.id} ...`);\n\n        this.socket = socket;\n        this.server = server;\n        this.state = ServerConnection.State.AWAITING_HANDSHAKE;\n\n        this.deferreds_ = {};\n        this.autoPing_ = debounce(() => {});\n\n        this.socket.on('message', this.onMessage_.bind(this));\n        this.socket.on('error', this.onError_.bind(this));\n        this.socket.on('close', this.onClose_.bind(this));\n\n        this.idleTimeout = new Deferred();\n        this.idleTimeoutDuration = server.options.pingInterval * 100;\n\n        if (server.options.pingInterval > 0) {\n            /**\n             * Handle the weird rare state of connection where despite a successful closure residuals still remain in rooms.\n             */\n            this.idleTimeout = new Deferred({timeout:  this.idleTimeoutDuration, rejectOnExpire: false,\n                onExpire: () => {\n                    const persistsInRoot = !!this.server.rooms.root.getConnectionById(this.id);\n                    const belongingRooms = this.getRooms().length;\n\n                    if (persistsInRoot || belongingRooms !== 0) {\n                        debug(`Could not dispose this connection somehow. ` +\n                              `ReadyState = ${['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'][this.socket.readyState]} | ` +\n                              `Persists in root room: ${persistsInRoot} | ` +\n                              `Belongs to this many rooms: ${belongingRooms}`);\n\n                        this.server.rooms.removeFromAll(this);\n                        this.server.rooms.root.remove(this);\n                        this.state = ServerConnection.State.DISCONNECTED;\n                        this.emit(ServerConnection.Event.DISCONNECTED,\n                                  ServerConnection.ErrorCode.IDLE_TIMEOUT,\n                                  `Stayed idle for ${this.idleTimeoutDuration}`);\n                    }\n                }\n            })\n\n            this.autoPing_ = debounce(() => {\n                this\n                    .ping()\n                    .then(() => {\n\n                        debug(`Auto-ping successful`);\n                        this.idleTimeout.delay();\n\n                        if (server.options.pingInterval > 0 && this.state == ServerConnection.State.CONNECTED) {\n                            this.autoPing_();\n                        } else {\n                            debug(`Canceling auto-ping, state: ${this.state}`);\n                        }\n                    })\n                    .catch((err) => {\n                        /* Disconnection is handled in ping */\n                        debug(`Auto-ping failed, state: ${this.state}`, err);\n                    });\n            }, server.options.pingInterval);\n        }\n\n        if (server.options.handshakeTimeout > 0) {\n            this.handshakeTimeout_ = setTimeout(() => {\n                if (this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n                    return debug(`Handshake is not awaiting, ignoring handshake timeout...`);\n                }\n\n                debug(`Handshake timeout exceed, closing the connection...`);\n                this.close(CloseStatus.HANDSHAKE_FAILED.code, `Handshake not completed after ${server.options.handshakeTimeout} ms`);\n            }, server.options.handshakeTimeout);\n        }\n    }\n\n\n    /**\n     * Native \"message\" event handler.\n     *\n     * @param {string|Buffer} data\n     * @param {Object} flags\n     * @param {boolean} flags.binary Specifies if data is binary.\n     * @param {boolean} flags.Boolean Specifies if data was masked.\n     * @ignore\n     */\n    onMessage_(data, flags) {\n        debug(`Native \"message\" event recieved: ${data}`);\n        let message;\n\n        // A message is recieved, debounce our auto-ping handler if connected\n        if (this.state == ServerConnection.State.CONNECTED) {\n            this.autoPing_();\n        }\n\n        try {\n            message = Message.parse(data);\n        } catch (err) {\n            this.emit(ServerConnection.Event.ERROR, new LineError(\n                ServerConnection.ErrorCode.INVALID_JSON,\n                'Could not parse message, invalid json. Check payload for incoming data.',\n                data\n            ));\n            return;\n        }\n\n        this.idleTimeout.delay();\n\n        /**\n         * Route the incoming message\n         */\n        if (message.name == Message.Name.HANDSHAKE) { // Handshake\n            this.onHandshakeMessage_(message);\n        } else if (message.name == Message.Name.PING) { // Ping\n            this.onPingMessage_(message);\n        } else if (message.name == Message.Name.RESPONSE) { // Message response\n            this.onResponseMessage_(message);\n        } else if (Message.ReservedNames.indexOf(message.name) == -1) { // If message name is not reserved\n            if (!message.id) { // Message without response (no id fields)\n                this.onMessageWithoutResponse_(message);\n            } else { // Message arrived awaiting its response\n                this.onMessageWithResponse_(message);\n            }\n        } else {\n            debug(`Could not route the message`, message);\n        }\n    }\n\n\n    /**\n     * On \"handshake\" message handler.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onHandshakeMessage_(message) {\n        if (this.state == ServerConnection.State.CONNECTED) {\n            debug(`Handshake message recieved but, handshake is already resolved, ignoring...`);\n            return this\n                .sendWithoutResponse_(message.createResponse(new Error('Handshake is already resolved')))\n                .catch(() => { /* Ignoring */ });\n        }\n\n        debug(`Handshake message recieved: ${message}`);\n\n        /**\n         * If handshake is resolved\n         */\n        message.once('resolved', (payload) => {\n            debug(`Handshake is resolved, sending response...`);\n            this.state = ServerConnection.State.CONNECTED;\n            this.handshakeTimeout_ && clearTimeout(this.handshakeTimeout_);\n            this.autoPing_(); // Start auto-pinging\n\n            const responsePayload = {\n                payload,\n                id: this.id\n            };\n\n            this\n                .sendWithoutResponse_(message.createResponse(null, responsePayload))\n                .then(() => {\n                    debug(`Handshake resolving response is sent, emitting connection...`);\n                    this.server.rooms.root.add(this);\n                    this.server.emit('connection', this);\n                })\n                .catch((err) => {\n                    debug(`Could not send handshake response`, err);\n\n                    // TODO: Emit these errors from the server\n                    if (err instanceof LineError) {\n                        switch (err.code) {\n                            case ServerConnection.ErrorCode.DISCONNECTED:\n                                debug(`Connection is gone before handshake completed, ignoring...`);\n                                return;\n\n                            case ServerConnection.ErrorCode.WEBSOCKET_ERROR:\n                                // TODO: Try again!\n                                debug(`Native websocket error`, err.payload);\n                                return this.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n\n                            default:\n                                debug(`Unhandled line error`, err);\n                                return this.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                        }\n                    }\n\n                    debug(`Unknown error`, err);\n                    return this.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                })\n                .then(() => {\n                    message.dispose();\n                });\n        });\n\n        /**\n         * Id handshake is rejected\n         */\n        message.once('rejected', (err) => {\n            debug(`Handshake is rejected, sending response...`);\n\n            this\n                .sendWithoutResponse_(message.createResponse(err))\n                .catch(err => debug(`Handshake rejecting response could not sent, manually calling \"close\"...`, err))\n                .then(() => this.close(CloseStatus.HANDSHAKE_REJECTED.code, CloseStatus.HANDSHAKE_REJECTED.reason, 50))\n                .then(() => {\n                    message.dispose();\n                });\n        });\n\n        /**\n         * Emit handshake event from the server\n         */\n        debug(`Emitting server's \"handshake\" event...`);\n        const handshakeListener = this.server.emit('handshake', this, message);\n\n        if (!handshakeListener) {\n            debug(`There is no handshake listener, resolving the handshake by default...`);\n            message.resolve();\n        }\n    }\n\n\n    /**\n     * On \"ping\" message handler. Reply with pong.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onPingMessage_(message) {\n        debug(`Ping received, responding with \"pong\"...`);\n\n        this\n            .sendWithoutResponse_(message.createResponse(null, 'pong'))\n            .catch(err => debug(`Ping response failed to send back, ignoring for now...`, err));\n    }\n\n\n    /**\n     * A message is recieved, and its response is expected.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onResponseMessage_(message) {\n        const deferred = this.deferreds_[message.id];\n        if (!deferred) return;\n\n        if (message.err) {\n            debug(`Response (rejecting) recieved: ${message}`);\n            const err = new LineError(\n                ServerConnection.ErrorCode.MESSAGE_REJECTED,\n                'Message is rejected by server, check payload.',\n                message.err\n            );\n            deferred.reject(err);\n        } else {\n            debug(`Response (resolving) recieved: ${message}`);\n            deferred.resolve(message.payload);\n        }\n\n        delete this.deferreds_[message.id];\n    }\n\n\n    /**\n     * A message is arrived without waiting its response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithoutResponse_(message) {\n        debug(`Message without response: name=\"${message.name}\"`);\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * A message is arrived and the client is expecting its response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithResponse_(message) {\n        debug(`Message with response: name=\"${message.name}\" id=\"${message.id}\"`);\n\n        message.once('resolved', (payload) => {\n            debug(`Message #${message.id} is resolved, sending response...`);\n            this\n                .sendWithoutResponse_(message.createResponse(null, payload))\n                .catch((err) => {\n                    this.emit(ServerConnection.Event.ERROR, new LineError(\n                        ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (resolve)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        message.once('rejected', (err) => {\n            debug(`Message #${message.id} is rejected, sending response...`);\n            this\n                .sendWithoutResponse_(message.createResponse(err))\n                .catch((err) => {\n                    this.emit(ServerConnection.Event.ERROR, new LineError(\n                        ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (reject)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * Native \"error\" event.\n     *\n     * @param {Error} err\n     * @ignore\n     */\n    onError_(err) {\n        debug(`Native \"error\" event recieved, emitting line's \"error\" event: ${err}`);\n        this.emit(ServerConnection.Event.ERROR, err);\n    }\n\n\n    /**\n     * Native \"close\" event.\n     *\n     * @param {number} code\n     * @param {string=} reason\n     * @ignore\n     */\n    onClose_(code, reason) {\n        debug(`Native \"close\" event recieved with code ${code}: ${reason}`);\n        debug(`Removing connection from all rooms, rejecting all waiting messages...`);\n\n        this.handshakeTimeout_ && clearTimeout(this.handshakeTimeout_);\n        this.autoPing_.cancel();\n        this.server.rooms.removeFromAll(this);\n        this.server.rooms.root.remove(this);\n        this.rejectAllDeferreds_(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Socket connection closed!'));\n\n        debug(`Emitting line's \"close\" event...`);\n        this.state = ServerConnection.State.DISCONNECTED;\n        this.emit(ServerConnection.Event.DISCONNECTED, code, reason);\n    }\n\n\n    /**\n     * Changes connection's id, it's random by default. This method is helpful if you already have\n     * custom identification for your clients. You must do this before handshake resolved. If\n     * handshake is already resolved or there is conflict, this method will throw error.\n     *\n     * Throws:\n     * - `ServerConnection.ErrorCode.HANDSHAKE_ENDED`: Id could not be changed after handshake\n     * - `ServerConnection.ErrorCode.ID_CONFLICT`: There is alrady another connection with provided id.\n     *\n     * @param {string} newId New connection id\n     * @memberOf ServerConnection\n     * @example\n     * server.on(Server.Event.HANDSHAKE, (connection, handshake) => {\n     *   // Assuming client's `options.handshake.payload` is something like `{authToken: '...'}`\n     *\n     *   // Imaginary db\n     *   db.find(handshake.payload.authToken, (record) => {\n     *     if (!record) return handshake.reject(new Error('Invalid auth token'));\n     *     connection.setId(record.id);\n     *     handshake.resolve(record);\n     *   });\n     * });\n     */\n    setId(newId) {\n        if (this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n            throw new LineError(\n                ServerConnection.ErrorCode.HANDSHAKE_ENDED,\n                'Handshake already ended, you cannot change connection id anymore'\n            );\n        }\n\n        if (this.server.getConnectionById(newId)) {\n            throw new LineError(\n                ServerConnection.ErrorCode.ID_CONFLICT,\n                `Conflict! There is already connection with id ${newId}`\n            );\n        }\n\n        this.id = newId;\n        debug = Debug(`line:server:connection:${this.id}`);\n    }\n\n\n    /**\n     * Joins the connection into provided room. If there is no room, it will be created automatically.\n     *\n     * @param {string} roomName\n     * @memberOf ServerConnection\n     */\n    joinRoom(roomName) {\n        this.server.rooms.add(roomName, this);\n    }\n\n\n    /**\n     * Leaves the connection from provided room.\n     *\n     * @param {string} roomName\n     * @memberOf ServerConnection\n     */\n    leaveRoom(roomName) {\n        this.server.rooms.remove(roomName, this);\n    }\n\n\n\n    /**\n     * Gets the joined room names.\n     *\n     * @returns {Array<string>}\n     * @memberOf ServerConnection\n     */\n    getRooms() {\n        return this.server.rooms.getRoomsOf(this);\n    }\n\n\n    /**\n     * Sends a message to client with awaiting its response. This method returns a promise\n     * which resolves the payload parameter will be passed into `message.resolve(...)` in client-side.\n     *\n     * If client rejects the message with `message.reject(...)`, this promise will be rejected with\n     * `ServerConnection.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n     * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {string} name\n     * @param {any=} payload\n     * @param {number=} timout\n     * @returns {Promise<any>}\n     * @memberOf ServerConnection\n     * @example\n     * connection\n     *   .send('hello', {optional: 'payload'})\n     *   .then((data) => {\n     *     // Message is resolved by client\n     *   })\n     *   .catch((err) => {\n     *     // Could not send message\n     *     // or\n     *     // Client rejected the message!\n     *   });\n     */\n    send(name, payload, opt_timeout) { // This method is for external usage!\n        if (this.state != ServerConnection.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload});\n            return this.send_(message, opt_timeout);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Sends a message to client without waiting its response. This method returns a promise\n     * that resolves with nothing if the message is successfully sent.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {string} name\n     * @param {any=} payload\n     * @returns {Promise}\n     * @memberOf ServerConnection\n     * @example\n     * connection\n     *   .sendWithoutResponse('hello', {optional: 'payload'})\n     *   .then(() => {\n     *     // Message sent successfully\n     *   })\n     *   .catch((err) => {\n     *     // Message could not be sent to client\n     *   })\n     */\n    sendWithoutResponse(name, payload) { // For external usage\n        if (this.state != ServerConnection.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload}); // Can throw Message.ErrorCode.INVALID_JSON\n            return this.sendWithoutResponse_(message);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Base method for sending a message with timeout. Please favor this method internally\n     * instead of using `send` method.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n     * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {Message} message\n     * @param {number=} opt_timeout\n     * @returns {Promise}\n     * @ignore\n     */\n    send_(message, opt_timeout) {\n        const timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.server.options.responseTimeout;\n        message.setId();\n\n        const deferred = this.deferreds_[message.id] = new Deferred({\n            onExpire: () => {\n                delete this.deferreds_[message.id];\n            },\n            timeout: timeout\n        });\n\n        return this\n            .sendWithoutResponse_(message)\n            .then(() => deferred)\n            .catch((err) => {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(\n                        ServerConnection.ErrorCode.MESSAGE_TIMEOUT,\n                        `Message timeout! Its response did not recived after ${timeout} ms`\n                    );\n                }\n\n                throw err;\n            });\n    }\n\n\n    /**\n     * Base method for sending a message without response. Please favor this method internally\n     * instead of using `sendWithoutResponse` method.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {Message} message\n     * @returns {Promise}\n     * @ignore\n     */\n    sendWithoutResponse_(message) {\n        if (!this.socket || this.socket.readyState != 1) {\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.DISCONNECTED,\n                `Could not send message, there is no open connection.`\n            ));\n        }\n\n        return new Promise((resolve, reject) => {\n            debug(`Sending message: ${message}`);\n            const messageStr = message.toString();\n\n            this.socket.send(messageStr, (err) => {\n                if (err) {\n                    return reject(new LineError(\n                        ServerConnection.ErrorCode.WEBSOCKET_ERROR,\n                        `Could not send message, native websocket error, check payload.`,\n                        err\n                    ));\n                }\n\n                resolve();\n            });\n        });\n    }\n\n\n    /**\n     * Pings the client. If there is no respose, closes the connection.\n     *\n     * @returns {Promise}\n     * @memberOf ServerConnection\n     */\n    ping() {\n        debug(`Pinging...`);\n        return this\n            .send_(new Message({name: Message.Name.PING}))\n            .catch(err => {\n                // No matter what error is, start disconnection process\n                debug(`Auto-ping failed, manually disconnecting...`, err);\n                this.close(CloseStatus.PING_FAILED.code, CloseStatus.PING_FAILED.reason);\n                throw new LineError(\n                    ServerConnection.ErrorCode.PING_ERROR,\n                    `Ping failed, manually disconnecting...`,\n                    err\n                );\n            });\n    }\n\n\n    /**\n     * Gracefully closes the client connection.\n     *\n     * @param {number=} code\n     * @param {string=} reason\n     * @param {number=} delay\n     * @returns {Promise}\n     */\n    close(code, reason, delay) {\n        debug(`Closing the connection in ${delay || 0} ms with code: ${code}.`);\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                this.socket.close(code || 1000, reason);\n            }, delay || 0);\n        });\n    }\n\n\n    /**\n     * Reject all the awaiting deferred with given error.\n     *\n     * @param {Error} err An error object to reject all awaiting deferreds.\n     * @ignore\n     */\n    rejectAllDeferreds_(err) {\n        forEach(this.deferreds_, deferred => deferred.reject(err));\n        this.deferreds_ = {};\n    }\n}\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.ErrorCode = {\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method.\n     */\n    MESSAGE_TIMEOUT: 'scMessageTimeout',\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method,\n     * which again indicates that server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'scMessageRejected',\n    /**\n     * When the response of a message failed to send to client, this error\n     * will be emitted in `ServerConnection.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'scInvalidJson',\n    /**\n     * This error can be thrown in `serverConnection.setId()`. Connection id\n     * cannot be set after handshake.\n     */\n    HANDSHAKE_ENDED: 'scHandshakeEnded',\n    /**\n     * This error can be seen while using `serverConnection.setId()`. If there is\n     * already connection with that id, this error will be thrown.\n     */\n    ID_CONFLICT: 'scIdConflict',\n    /**\n     * This error indicates client is disconnected.\n     */\n    DISCONNECTED: 'scDisconnected',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'scWebsocketError',\n    /**\n     * This error can be seen in rejection of `serverConnection.ping()` method.\n     */\n    PING_ERROR: 'scPingError',\n    /**\n     * This error is thrown when a connection won't ping-pong for too long.\n     */\n    IDLE_TIMEOUT: 'scIdleTimeout'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.State = {\n    /**\n     * `awaitingHandshake` Connection is open but handshake is not completed yet.\n     */\n    AWAITING_HANDSHAKE: 'awaitingHandshake',\n    /**\n     * `connected` Connection is open and handshake resolved.\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnected` There is no open connection.\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.Event = {\n    /**\n     * `_error`\n     */\n    ERROR: '_error',\n    /**\n     * `_close`\n     */\n    DISCONNECTED: '_disconnected'\n};\n\n\nmodule.exports = ServerConnection;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/connection.js","const filter = require('lodash/filter');\nconst forEach = require('lodash/forEach');\nconst map = require('lodash/map');\nconst Room = require('./room');\n\n\nclass Rooms {\n    constructor() {\n        this.rooms = {};\n        this.root = new Room();\n    }\n\n    add(roomName, connection) {\n        if(!this.rooms[roomName])\n            this.rooms[roomName] = new Room(roomName);\n\n        this.rooms[roomName].add(connection);\n    }\n\n    remove(roomName, connection) {\n        if(!this.rooms[roomName])\n            return;\n\n        this.rooms[roomName].remove(connection);\n\n        if (!this.rooms[roomName].getConnectionsCount())\n            delete this.rooms[roomName];\n    }\n\n    getRoomsOf(connection) {\n        return map(filter(this.rooms, room => room.getConnectionById(connection.id)), 'name');\n    }\n\n    getRoom(room) {\n        return this.rooms[room];\n    }\n\n    removeFromAll(connection) {\n        const rooms = this.getRoomsOf(connection);\n        forEach(rooms, roomName => this.rooms[roomName].remove(connection));\n    }\n}\n\n\nmodule.exports = Rooms;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/rooms.js","module.exports = require(\"uws\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"uws\"\n// module id = 10\n// module chunks = 0","module.exports = require(\"ws\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ws\"\n// module id = 11\n// module chunks = 0","module.exports = {\n    INTERNAL_ERROR: {code: 4200, reason: 'Internal error'},\n    PING_FAILED: {code: 4201, reason: 'Ping failed'},\n    HANDSHAKE_FAILED: {code: 4202, reason: 'Handshake failed'},\n    HANDSHAKE_REJECTED: {code: 4203, reason: 'Handshake rejected'},\n    DISCONNECT_TIMEOUT: {code: 4204, reason: 'Disconnect timeout'},\n    DISPOSED: {code: 4205, reason: 'Client disposed'},\n    UNKNOWN_ERROR: {code: 4299, reason: 'Unknown error'},\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/closestatus.js","const LineError = require('./error');\n\n\nclass Deferred {\n    constructor({\n        handler = () => {},\n        onExpire = () => {},\n        timeout = 0,\n        rejectOnExpire = true\n    } = {}) {\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.rejectOnExpire_ = rejectOnExpire;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve_ = resolve;\n            this.reject_ = reject;\n\n            try {\n                handler(this);\n            } catch (err) {\n                this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n\n    resolve(data) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.resolve_(data);\n    }\n\n\n    reject(err) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.reject_(err);\n    }\n\n\n    expire() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.onExpire_();\n\n        if (this.rejectOnExpire_)\n            this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, `Timeout ${this.timeoutDuration_} ms exceed`));\n    }\n\n\n    dispose() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n    }\n\n    delay(timeout) {\n        if (this.timeoutDuration_ > 0) {\n            this.clearTimeout_();\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout || this.timeoutDuration_);\n        }\n    }\n\n    then(...args) {\n        return this.promise.then.apply(this.promise, args);\n    }\n\n\n    catch(...args) {\n        return this.promise.catch.apply(this.promise, args);\n    }\n\n\n    clearTimeout_() {\n        if (this.timeout_) {\n            clearTimeout(this.timeout_);\n            this.timeout_ = null;\n        }\n    }\n}\n\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\n\nmodule.exports = Deferred;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/deferred.js","const assign = require('lodash/assign');\n\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId(length = 4) {\n    return (\"0000\" + (Math.random()*Math.pow(36,length) << 0).toString(36)).slice(-length);\n}\n\n\nmodule.exports = {generateDummyId};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/utils.js","const forEach = require('lodash/forEach');\nconst clone = require('lodash/clone');\nconst Message = require('../lib/message');\nconst debug = require('debug')('line:server:room');\nconst LineError = require('../lib/error');\n\n\n/**\n * Line room class.\n *\n * @private\n * @class ServerRoom\n * @param {string} name Room name\n * @property {string} name\n */\nclass ServerRoom {\n    constructor(name, connections = {}) {\n        this.name = name;\n        this.connections = connections;\n    }\n\n\n    /**\n     * Adds a connection into room.\n     * @param {ServerConnection} connection\n     */\n    add(connection) {\n        // TODO: Check current existing connection maybe?\n        this.connections[connection.id] = connection;\n    }\n\n\n    /**\n     * Removes a connection from room.\n     * @param {ServerConnection} connection\n     * @returns {boolean}\n     */\n    remove(connection) {\n        if (connection != this.connections[connection.id]) {\n            debug(`[${this.name || 'root'}] Did not remove \"${connection.id}\", connection instance is not added or different`);\n            return false;\n        }\n\n        debug(`[${this.name || 'root'}] Removing \"${connection.id}\"`);\n        delete this.connections[connection.id];\n        return true;\n    }\n\n\n    /**\n     * Gets a connection by id.\n     * @param {string} connectionId\n     * @returns {?ServerConnection}\n     */\n    getConnectionById(connectionId) {\n        return this.connections[connectionId];\n    }\n\n\n    /**\n     * Gets all connections in the room. Returns a object where keys are\n     * connection id and values are ServerConnection.\n     * @returns {{string: ServerConnection}}\n     */\n    getConnections() {\n        return clone(this.connections);\n    }\n\n\n    /**\n     * Returns the total connection count in room.\n     * @returns {number}\n     */\n    getConnectionsCount() {\n        return Object.keys(this.connections).length;\n    }\n\n\n    broadcast_(message) {\n        forEach(this.connections, connection => {\n            connection\n                .sendWithoutResponse_(message)\n                .catch((err) => {\n                    debug(`[${this.name || 'root'}] Could not send \"${message.name}\" to \"${connection.id}\" while broadcasting, ignoring...`);\n                });\n        });\n    }\n\n\n    /**\n     * Broadcast a message to all connections in the room.\n     * @param {string} name\n     * @param {any=} payload\n     */\n    broadcast(name, payload) {\n        const message = new Message({name, payload}); // Can throw INVALID_JSON\n        this.broadcast_(message);\n    }\n}\n\n\nmodule.exports = ServerRoom;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/room.js","module.exports = require(\"lodash/clone\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/clone\"\n// module id = 16\n// module chunks = 0","module.exports = require(\"lodash/debounce\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/debounce\"\n// module id = 17\n// module chunks = 0","module.exports = require(\"lodash/filter\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/filter\"\n// module id = 18\n// module chunks = 0","module.exports = require(\"lodash/isFunction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isFunction\"\n// module id = 19\n// module chunks = 0","module.exports = require(\"lodash/isString\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isString\"\n// module id = 20\n// module chunks = 0","module.exports = require(\"lodash/isUndefined\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isUndefined\"\n// module id = 21\n// module chunks = 0","module.exports = require(\"lodash/map\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/map\"\n// module id = 22\n// module chunks = 0","module.exports = require(\"lodash/values\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/values\"\n// module id = 23\n// module chunks = 0","module.exports = require(\"uuid\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"uuid\"\n// module id = 24\n// module chunks = 0","const Connection = require('./connection');\nconst Message = require('../lib/message');\nconst Rooms = require('./rooms');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst debug = require('debug')('line:server');\nconst LineError = require('../lib/error');\nconst assign = require('lodash/assign');\nconst isInteger = require('lodash/isInteger');\n\nlet WebSocketServer;\ntry {\n    WebSocketServer = require('uws').Server;\n} catch (err) {\n    WebSocketServer = require('ws').Server;\n    debug(`Could not find module uws, falling back to ws`, err);\n}\n\n\n/**\n * Line Server Class\n *\n * @class Server\n * @extends {EventEmitterExtra}\n * @param {Object=} options Options object.\n * @param {string=} options.host The hostname where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.port The port where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {http.Server=} options.server A pre-created Node.js HTTP server. If provided, `host` and `port`\n *      will ignored. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {string=} options.path Accept only connections matching this path. [Inherited from uws](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.responseTimeout Default timeout duration (in ms) for message responses. Default: `10000` (10 seconds)\n * @param {number=} options.handshakeTimeout This is the duration how long a client can stay connected\n *      without handshake. Default `60000` (1 minute).\n * @param {number=} options.pingInterval Ping interval in ms. Default: 15 seconds.\n * @example\n * const Server = require('line-socket/server');\n * const server = new Server({\n *   port: 8080\n * });\n */\nclass Server extends EventEmitterExtra {\n    constructor(options = {}) {\n        super();\n\n        this.options = assign({\n            responseTimeout: 10000,\n            handshakeTimeout: 60000,\n            pingInterval: 15000\n        }, options);\n\n        if (!isInteger(this.options.responseTimeout) || this.options.responseTimeout < 0)\n            throw new LineError(Server.ErrorCode.INVALID_OPTIONS, `\"options.responseTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.handshakeTimeout) || this.options.handshakeTimeout < 0)\n            throw new LineError(Server.ErrorCode.INVALID_OPTIONS, `\"options.handshakeTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.pingInterval) || this.options.pingInterval < 0)\n            throw new LineError(Server.ErrorCode.INVALID_OPTIONS, `\"options.pingInterval\" must be a positive integer or zero`);\n\n        this.rooms = new Rooms();\n\n        debug(`Initalizing with options: ${JSON.stringify(this.options)}`);\n    }\n\n    /**\n     * Starts the server.\n     *\n     * @returns {Promise}\n     * @memberOf Server\n     * @example\n     * server\n     *   .start()\n     *   .then(() => {\n     *     console.log('Server started');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Server could not started', err);\n     *   });\n     */\n    start() {\n        if (this.server) {\n            return Promise.reject(new LineError(\n                Server.ErrorCode.INVALID_ACTION,\n                `Could not start server, already started!`\n            ));\n        }\n\n        if (!this.options.port) {\n            debug(`Starting without port...`);\n\n            try {\n                this.server = new WebSocketServer(this.options);\n                this.bindEvents_();\n                return Promise.resolve();\n            } catch (err) {\n                return Promise.reject(new LineError(\n                    Server.ErrorCode.WEBSOCKET_ERROR,\n                    `Could not start the server, websocket error, check payload`,\n                    err\n                ));\n            }\n        }\n\n        return new Promise((resolve, reject) => {\n            debug(`Starting with port \"${this.options.port}\" ...`);\n\n            this.server = new WebSocketServer(this.options, err => {\n                if (err) {\n                    debug(`Could not start: ${err}`);\n                    return reject(new LineError(\n                        Server.ErrorCode.WEBSOCKET_ERROR,\n                        `Could not start the server, websocket error, check payload`,\n                        err\n                    ));\n                }\n\n                this.bindEvents_();\n                resolve();\n            });\n        })\n    }\n\n\n    /**\n     * Stops the server.\n     *\n     * @returns {Promise}\n     * @memberOf Server\n     * @example\n     * server\n     *   .stop()\n     *   .then(() => {\n     *     console.log('Server stopped');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Server could not stopped', err);\n     *   });\n     */\n    stop() {\n        if (!this.server) {\n            debug(`Could not stop server. Server is probably not started, or already stopped.`);\n            return Promise.reject(new LineError(\n                Server.ErrorCode.INVALID_ACTION,\n                `Could not stop server. Server is probably not started, or already stopped!`\n            ));\n        }\n\n        return new Promise(resolve => {\n            debug(`Closing and disposing the server...`);\n            this.server.close();\n            this.server = null;\n            resolve();\n        });\n    }\n\n\n    /**\n     * Binds websocket server events.\n     *\n     * @ignore\n     */\n    bindEvents_() {\n        debug(`Binding server events...`);\n\n        this.server.on('connection', this.onConnection_.bind(this));\n        this.server.on('headers', this.onHeaders_.bind(this));\n        this.server.on('error', this.onError_.bind(this));\n    }\n\n\n    /**\n     * Native \"connection\" event handler.\n     *\n     * @param {WebSocket} socket\n     * @ignore\n     */\n    onConnection_(socket) {\n        debug(`Native \"connection\" event recieved, creating line connection...`);\n        const connection = new Connection(socket, this);\n    }\n\n\n    /**\n     * Native \"headers\" event handler.\n     *\n     * @param {Array} headers\n     * @ignore\n     */\n    onHeaders_(headers) {\n        debug(`Native \"headers\" event recieved, emitting line's \"headers\" event... (${headers})`);\n        this.emit(Server.Event.HEADERS, headers);\n    }\n\n\n    /**\n     * Native \"error\" event handler.\n     *\n     * @param {Error} err\n     * @ignore\n     */\n    onError_(err) {\n        debug(`Native \"error\" event recieved, emitting line's \"error\" event... (${err})`);\n        this.emit(Server.Event.ERROR, err);\n    }\n\n\n    /**\n     * Returns a object where keys are connection id and values are ServerConnection.\n     *\n     * @returns {{string: ServerConnection}}\n     * @memberOf Server\n     */\n    getConnections() {\n        return this.rooms.root.getConnections();\n    }\n\n\n    /**\n     * Gets a connection by id\n     *\n     * @param {string} id Unique connection id, which can be accessed at `connection.id`\n     * @returns {?ServerConnection}\n     * @memberOf Server\n     * @example\n     * const connection = server.getConnectionById('someId');\n     *\n     * if (connection) {\n     *   connection.send('hello', {optional: 'payload'});\n     * }\n     */\n    getConnectionById(id) {\n        return this.rooms.root.getConnectionById(id);\n    }\n\n\n    /**\n     * Broadcasts a message to all the connected (& handshaked) clients.\n     *\n     * @param {string} name Message name\n     * @param {any=} payload Optional message payload.\n     * @memberOf Server\n     * @example\n     * server.broadcast('hello', {optional: 'payload'});\n     */\n    broadcast(name, payload) {\n        debug(`Broadcasting \"${name}\" message...`);\n        this.rooms.root.broadcast(name, payload); // Can throw INVALID_JSON\n    }\n\n\n    /**\n     * Gets a room by name.\n     * @param {string} room Room name\n     * @returns {?ServerRoom}\n     */\n    getRoom(room) {\n        return this.rooms.getRoom(room);\n    }\n\n    /**\n     * Gets all the rooms of a connection.\n     * @param {ServerConnection} connection\n     * @returns {Array.<string>} Array of room names.\n     */\n    getRoomsOf(connection) {\n        return this.rooms.getRoomsOf(connection);\n    }\n\n\n    /**\n     * Remove a connection from all the rooms.\n     * @param {ServerConnection} connection\n     */\n    removeFromAllRooms(connection) {\n        this.rooms.removeFromAll(connection);\n    }\n}\n\n\n// Expose internal classes\nServer.Message = Message;\nServer.Connection = Connection;\nServer.Error = LineError;\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServer.ErrorCode = {\n    /**\n     * When constructing `new Server()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'sInvalidOptions',\n    /**\n     * This error can be seen in rejection of `server.start()` or `server.stop()` methods.\n     */\n    INVALID_ACTION: 'sInvalidAction',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'sWebsocketError'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n * @example\n * server.on('connection', (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // or better, you can use enums\n *\n * server.on(Server.Event.CONNECTION, (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // If you want to authorize your client\n * server.on('handshake', (connection, handshake) => {\n *   if (handshake.payload && handshake.payload.authToken == '...')\n *     handshake.resolve({welcome: 'bro'});\n *   else\n *     handshake.reject(new Error('Invalid auth token'));\n * });\n */\nServer.Event = {\n    /**\n     * `handshake` When a client connection is established, this event will be fired before\n     * `connection` event. Please note that, this event has nothing in common with native websocket\n     * handshaking process. If you want to authorize your clients, you must listen this event and\n     * call `handshake.resolve(...)` or `handshake.reject(...)` accordingly. If you do not consume\n     * this events, all the client connections will be accepted.\n     *\n     * ```\n     * function (connection, handshake) {}\n     * ```\n     *\n     * where `connection` is `ServerConnection` and `handshake` is a `Message` instance.\n     */\n    HANDSHAKE: 'handshake',\n    /**\n     * `connection` This event will fire on a client connects **after successful handshake**.\n     *\n     * ```\n     * function (connection) {}\n     * ```\n     *\n     * where `connection` is a `ServerConnection` instance.\n     */\n    CONNECTION: 'connection',\n    /**\n     * `'headers'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-headers)\n     */\n    HEADERS: 'headers',\n    /**\n     * `'error'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-error)\n     */\n    ERROR: 'error'\n};\n\n\nmodule.exports = Server;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/server.js"],"sourceRoot":""}